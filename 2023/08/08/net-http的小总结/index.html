<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-apple.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Tachiu Lam">
  <meta name="keywords" content="">
  <title>go net/http的小总结 - Tachiu Lam</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>TachiuLam's emmm...</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/go2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2023-08-08 23:24">
                    2023年8月8日 晚上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    2.1k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    36
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2023年8月8日 晚上
                
              </p>
            
            <article class="markdown-body">
              <h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;
   ServeHTTP(ResponseWriter, *Request)
&#125;

<span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;
   Addr <span class="hljs-keyword">string</span>
   
   <span class="hljs-comment">// 路由处理器</span>
   Handler Handler <span class="hljs-comment">// handler to invoke, http.DefaultServeMux if nil</span>

   TLSConfig *tls.Config
   ReadTimeout time.Duration
   ReadHeaderTimeout time.Duration
   WriteTimeout time.Duration
   IdleTimeout time.Duration
   MaxHeaderBytes <span class="hljs-keyword">int</span>
   TLSNextProto <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Server, *tls.Conn, Handler)</span></span>
   ConnState <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(net.Conn, ConnState)</span></span>
   ErrorLog *log.Logger
   BaseContext <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(net.Listener)</span> <span class="hljs-title">context</span>.<span class="hljs-title">Context</span></span>
   ConnContext <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, c net.Conn)</span> <span class="hljs-title">context</span>.<span class="hljs-title">Context</span></span>

   inShutdown atomicBool <span class="hljs-comment">// true when server is in shutdown</span>

   disableKeepAlives <span class="hljs-keyword">int32</span>     <span class="hljs-comment">// accessed atomically.</span>
   nextProtoOnce     sync.Once <span class="hljs-comment">// guards setupHTTP2_* init</span>
   nextProtoErr      error     <span class="hljs-comment">// result of http2.ConfigureServer if used</span>

   mu         sync.Mutex
   listeners  <span class="hljs-keyword">map</span>[*net.Listener]<span class="hljs-keyword">struct</span>&#123;&#125;
   activeConn <span class="hljs-keyword">map</span>[*conn]<span class="hljs-keyword">struct</span>&#123;&#125;
   doneChan   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;
   onShutdown []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>

   listenerGroup sync.WaitGroup
&#125;

<span class="hljs-comment">// Handler 路由处理器的实现</span>
<span class="hljs-keyword">type</span> ServeMux <span class="hljs-keyword">struct</span> &#123;
   mu    sync.RWMutex
   m     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]muxEntry
   es    []muxEntry <span class="hljs-comment">// slice of entries sorted from longest to shortest.</span>
   hosts <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// whether any patterns contain hostnames</span>
&#125;

<span class="hljs-keyword">type</span> muxEntry <span class="hljs-keyword">struct</span> &#123;
   h       Handler 
   pattern <span class="hljs-keyword">string</span>
&#125;</code></pre>
<h4 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h4><ul>
<li>m     map[string]muxEntry：维护path和handler的映射关系</li>
<li>es    []muxEntry 用于路由前缀匹配</li>
<li>muxEntry： 在handler外，冗余保存了path路径信息</li>
</ul>
<h3 id="handler和路由注册过程"><a href="#handler和路由注册过程" class="headerlink" title="handler和路由注册过程"></a>handler和路由注册过程</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><pre><code class="hljs golang">http.HandleFunc(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;
   _, _ = writer.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"pong"</span>))
&#125;)</code></pre>

<h4 id="HandleFunc"><a href="#HandleFunc" class="headerlink" title="HandleFunc"></a>HandleFunc</h4><p>补充内部单例实现的ServeMux</p>
<pre><code class="hljs golang"><span class="hljs-comment">// DefaultServeMux is the default ServeMux used by Serve.</span>
<span class="hljs-keyword">var</span> DefaultServeMux = &amp;defaultServeMux <span class="hljs-comment">// 单例</span>

<span class="hljs-keyword">var</span> defaultServeMux ServeMux

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>, handler <span class="hljs-keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;
   DefaultServeMux.HandleFunc(pattern, handler)
&#125;</code></pre>
<h4 id="ServeMux-HandleFunc"><a href="#ServeMux-HandleFunc" class="headerlink" title="ServeMux.HandleFunc"></a>ServeMux.HandleFunc</h4><p>将demo中传入的handler方法，包装成HandlerFunc 该类型实现了上述的 ServeHTTP(w ResponseWriter, r *Request) 接口，实现逻辑是函数自身的调用</p>
<pre><code class="hljs golang"><span class="hljs-comment">// HandleFunc registers the handler function for the given pattern.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>, handler <span class="hljs-keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;
   <span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: nil handler"</span>)
   &#125;
   mux.Handle(pattern, HandlerFunc(handler))
&#125;

<span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span> // 实现<span class="hljs-title">Handler</span> 请求处理接口</span>

<span class="hljs-comment">// ServeHTTP calls f(w, r).</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;
   f(w, r) <span class="hljs-comment">// 调用handler自身</span>
&#125;</code></pre>

<h4 id="ServeMux-Handle"><a href="#ServeMux-Handle" class="headerlink" title="ServeMux.Handle"></a>ServeMux.Handle</h4><p>路由及方法的注册<br>如果注册的路径pattern是以 /  结尾，则放入es中的合适位置，用于路径前缀匹配</p>
<pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">Handle</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>, handler Handler)</span></span> &#123;
   mux.mu.Lock()
   <span class="hljs-keyword">defer</span> mux.mu.Unlock()

   <span class="hljs-keyword">if</span> pattern == <span class="hljs-string">""</span> &#123;
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: invalid pattern"</span>)
   &#125;
   <span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: nil handler"</span>)
   &#125;
   <span class="hljs-keyword">if</span> _, exist := mux.m[pattern]; exist &#123;
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: multiple registrations for "</span> + pattern)
   &#125;

   <span class="hljs-keyword">if</span> mux.m == <span class="hljs-literal">nil</span> &#123;
      mux.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]muxEntry)
   &#125;
   e := muxEntry&#123;h: handler, pattern: pattern&#125;
   mux.m[pattern] = e
   <span class="hljs-keyword">if</span> pattern[<span class="hljs-built_in">len</span>(pattern)<span class="hljs-number">-1</span>] == <span class="hljs-string">'/'</span> &#123;
      mux.es = appendSorted(mux.es, e)
   &#125;

   <span class="hljs-keyword">if</span> pattern[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> &#123;
      mux.hosts = <span class="hljs-literal">true</span>
   &#125;
&#125;</code></pre>

<h3 id="服务启动过程"><a href="#服务启动过程" class="headerlink" title="服务启动过程"></a>服务启动过程</h3><h4 id="ListenAndServe"><a href="#ListenAndServe" class="headerlink" title="ListenAndServe"></a>ListenAndServe</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, handler Handler)</span> <span class="hljs-title">error</span></span> &#123;
   server := &amp;Server&#123;Addr: addr, Handler: handler&#125;
   <span class="hljs-keyword">return</span> server.ListenAndServe()
&#125;</code></pre>
<h4 id="srv-Server-ListenAndServe"><a href="#srv-Server-ListenAndServe" class="headerlink" title="(srv *Server) ListenAndServe()"></a>(srv *Server) ListenAndServe()</h4><p>调用net包，监听端口</p>
<pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;
   <span class="hljs-keyword">if</span> srv.shuttingDown() &#123;
      <span class="hljs-keyword">return</span> ErrServerClosed
   &#125;
   addr := srv.Addr
   <span class="hljs-keyword">if</span> addr == <span class="hljs-string">""</span> &#123;
      addr = <span class="hljs-string">":http"</span>
   &#125;
   ln, err := net.Listen(<span class="hljs-string">"tcp"</span>, addr)
   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
      <span class="hljs-keyword">return</span> err
   &#125;
   <span class="hljs-keyword">return</span> srv.Serve(ln)
&#125;</code></pre>

<h4 id="srv-Server-Serve"><a href="#srv-Server-Serve" class="headerlink" title="(srv *Server) Serve"></a>(srv *Server) Serve</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">Serve</span><span class="hljs-params">(l net.Listener)</span> <span class="hljs-title">error</span></span> &#123;
   <span class="hljs-comment">// ...</span>

   ctx := context.WithValue(baseCtx, ServerContextKey, srv)
   <span class="hljs-keyword">for</span> &#123;
      rw, err := l.Accept() <span class="hljs-comment">// 调用tcp 的accept方法</span>
   
    <span class="hljs-comment">// ... </span>

      c := srv.newConn(rw)
    <span class="hljs-comment">// ... </span>
      <span class="hljs-keyword">go</span> c.serve(connCtx)
   &#125;
&#125;</code></pre>

<ul>
<li>l.Accept()：在for循环中，会使用net包的tcp accept方法，原理是epoll多路复用技术Linux ，不会持续的自旋占用cpu时间片，而是有请求到来时，才由内核精准唤醒</li>
<li>newConn ： 封装http请求</li>
<li>go c.serve(connCtx)： 使用goroutine处理请求</li>
</ul>
<h4 id="c-conn-serve"><a href="#c-conn-serve" class="headerlink" title="(c *conn) serve"></a>(c *conn) serve</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">serve</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;
<span class="hljs-comment">// ...</span>
    serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req) <span class="hljs-comment">// 调用ServeHTTP方法</span>
<span class="hljs-comment">//...</span>
&#125;
sh serverHandler) ServeHTTP
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sh serverHandler)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(rw ResponseWriter, req *Request)</span></span> &#123;
   handler := sh.srv.Handler
   <span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;
      handler = DefaultServeMux <span class="hljs-comment">// 不传会补充单例的DefaultServeMux</span>
   &#125;
   <span class="hljs-keyword">if</span> req.RequestURI == <span class="hljs-string">"*"</span> &amp;&amp; req.Method == <span class="hljs-string">"OPTIONS"</span> &#123;
      handler = globalOptionsHandler&#123;&#125;
   &#125;

   <span class="hljs-keyword">if</span> req.URL != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(req.URL.RawQuery, <span class="hljs-string">";"</span>) &#123;
      <span class="hljs-keyword">var</span> allowQuerySemicolonsInUse <span class="hljs-keyword">int32</span>
      req = req.WithContext(context.WithValue(req.Context(), silenceSemWarnContextKey, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
         atomic.StoreInt32(&amp;allowQuerySemicolonsInUse, <span class="hljs-number">1</span>)
      &#125;))
      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
         <span class="hljs-keyword">if</span> atomic.LoadInt32(&amp;allowQuerySemicolonsInUse) == <span class="hljs-number">0</span> &#123;
            sh.srv.logf(<span class="hljs-string">"http: URL query contains semicolon, which is no longer a supported separator; parts of the query may be stripped when parsed; see golang.org/issue/25192"</span>)
         &#125;
      &#125;()
   &#125;

   handler.ServeHTTP(rw, req) <span class="hljs-comment">// handler是ServeMux，所以会走到ServeMux的实现</span>
&#125;</code></pre>

<h4 id="mux-ServeMux-ServeHTTP"><a href="#mux-ServeMux-ServeHTTP" class="headerlink" title="(mux *ServeMux) ServeHTTP"></a>(mux *ServeMux) ServeHTTP</h4><ul>
<li>找到路径对应的hanlder</li>
<li>调用该handler</li>
</ul>
<pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;
   <span class="hljs-keyword">if</span> r.RequestURI == <span class="hljs-string">"*"</span> &#123;
      <span class="hljs-keyword">if</span> r.ProtoAtLeast(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#123;
         w.Header().Set(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"close"</span>)
      &#125;
      w.WriteHeader(StatusBadRequest)
      <span class="hljs-keyword">return</span>
   &#125;
   h, _ := mux.Handler(r) <span class="hljs-comment">// 这里👇</span>
   h.ServeHTTP(w, r)
&#125;</code></pre>

<h4 id="mux-ServeMux-Handler"><a href="#mux-ServeMux-Handler" class="headerlink" title="(mux *ServeMux) Handler("></a>(mux *ServeMux) Handler(</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">Handler</span><span class="hljs-params">(r *Request)</span> <span class="hljs-params">(h Handler, pattern <span class="hljs-keyword">string</span>)</span></span> &#123;

   <span class="hljs-comment">// CONNECT requests are not canonicalized.</span>
   <span class="hljs-keyword">if</span> r.Method == <span class="hljs-string">"CONNECT"</span> &#123;
      <span class="hljs-comment">// If r.URL.Path is /tree and its handler is not registered,</span>
      <span class="hljs-comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span>
      <span class="hljs-comment">// but the path canonicalization does not.</span>
      <span class="hljs-keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;
         <span class="hljs-keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path
      &#125;

      <span class="hljs-keyword">return</span> mux.handler(r.Host, r.URL.Path)
   &#125;

   <span class="hljs-comment">// All other requests have any port stripped and path cleaned</span>
   <span class="hljs-comment">// before passing to mux.handler.</span>
   host := stripHostPort(r.Host)
   path := cleanPath(r.URL.Path)

   <span class="hljs-comment">// If the given path is /tree and its handler is not registered,</span>
   <span class="hljs-comment">// redirect for /tree/.</span>
   <span class="hljs-keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;
      <span class="hljs-keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path
   &#125;

   <span class="hljs-keyword">if</span> path != r.URL.Path &#123;
      _, pattern = mux.handler(host, path)
      u := &amp;url.URL&#123;Path: path, RawQuery: r.URL.RawQuery&#125;
      <span class="hljs-keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), pattern
   &#125;

   <span class="hljs-keyword">return</span> mux.handler(host, r.URL.Path)
&#125;</code></pre>

<pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">handler</span><span class="hljs-params">(host, path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(h Handler, pattern <span class="hljs-keyword">string</span>)</span></span> &#123;
   mux.mu.RLock()
   <span class="hljs-keyword">defer</span> mux.mu.RUnlock()

   <span class="hljs-comment">// Host-specific pattern takes precedence over generic ones</span>
   <span class="hljs-keyword">if</span> mux.hosts &#123;
      h, pattern = mux.match(host + path) <span class="hljs-comment">// 补充左斜杠</span>
   &#125;
   <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;
      h, pattern = mux.match(path)
   &#125;
   <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;
      h, pattern = NotFoundHandler(), <span class="hljs-string">""</span>
   &#125;
   <span class="hljs-keyword">return</span>
&#125;</code></pre>
<pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">match</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(h Handler, pattern <span class="hljs-keyword">string</span>)</span></span> &#123;
   <span class="hljs-comment">// Check for exact match first.</span>
   v, ok := mux.m[path] <span class="hljs-comment">// 精准匹配，命中即返回对应的handler</span>
   <span class="hljs-keyword">if</span> ok &#123;
      <span class="hljs-keyword">return</span> v.h, v.pattern
   &#125;

   <span class="hljs-comment">// Check for longest valid match.  mux.es contains all patterns</span>
   <span class="hljs-comment">// that end in / sorted from longest to shortest.</span>
   <span class="hljs-comment">// 模糊匹配，es是按pattern从长到短排序，匹配也是从长到短</span>
   <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> mux.es &#123;
      <span class="hljs-keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;
         <span class="hljs-keyword">return</span> e.h, e.pattern <span class="hljs-comment">// 如果命中pattern的前缀，就返回对应handler</span>
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-string">""</span>
&#125;</code></pre>
<p>路由匹配机制<br>所以实际net/http包实现的路由匹配机制比较粗糙，</p>
<ol>
<li>精准匹配，命中map中的pattern 即返回对应的handler</li>
<li>模糊匹配，在es列表中（按pattern长度从长到短）进行前缀模糊匹配，命中即返回对应的handler</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>同样有默认的单例实现</p>
<pre><code class="hljs golang"><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;
   Transport RoundTripper <span class="hljs-comment">// 通信模块</span>

   Jar CookieJar
   
   CheckRedirect <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(req *Request, via []*Request)</span> <span class="hljs-title">error</span></span>
   
   Timeout time.Duration
&#125;</code></pre>
<h3 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h3><p>RoundTripper 的实现</p>
<pre><code class="hljs golang"><span class="hljs-keyword">type</span> Transport <span class="hljs-keyword">struct</span> &#123;
   idleMu       sync.Mutex
   closeIdle    <span class="hljs-keyword">bool</span>                                <span class="hljs-comment">// user has requested to close all idle conns</span>
   <span class="hljs-comment">// 放置空闲连接的map，用于复用（连接到同一服务端的）</span>
   idleConn     <span class="hljs-keyword">map</span>[connectMethodKey][]*persistConn <span class="hljs-comment">// most recently used at end</span>
   idleConnWait <span class="hljs-keyword">map</span>[connectMethodKey]wantConnQueue  <span class="hljs-comment">// waiting getConns</span>
   idleLRU      connLRU

   reqMu       sync.Mutex
   reqCanceler <span class="hljs-keyword">map</span>[cancelKey]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(error)</span></span>

   altMu    sync.Mutex   <span class="hljs-comment">// guards changing altProto only</span>
   altProto atomic.Value <span class="hljs-comment">// of nil or map[string]RoundTripper, key is URI scheme</span>

   connsPerHostMu   sync.Mutex
   connsPerHost     <span class="hljs-keyword">map</span>[connectMethodKey]<span class="hljs-keyword">int</span>
   connsPerHostWait <span class="hljs-keyword">map</span>[connectMethodKey]wantConnQueue <span class="hljs-comment">// waiting getConns</span>

   Proxy <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span> <span class="hljs-params">(*url.URL, error)</span></span>
    <span class="hljs-comment">// 新连接生成器</span>
   DialContext <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, network, addr <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span>

   Dial <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(network, addr <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span>

   DialTLSContext <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, network, addr <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span>

   DialTLS <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(network, addr <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span>

   TLSClientConfig *tls.Config

   TLSHandshakeTimeout time.Duration

   DisableKeepAlives <span class="hljs-keyword">bool</span>

   DisableCompression <span class="hljs-keyword">bool</span>

   MaxIdleConns <span class="hljs-keyword">int</span>
   MaxIdleConnsPerHost <span class="hljs-keyword">int</span>
   MaxConnsPerHost <span class="hljs-keyword">int</span>
   IdleConnTimeout time.Duration
   ResponseHeaderTimeout time.Duration
   ExpectContinueTimeout time.Duration
   TLSNextProto <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(authority <span class="hljs-keyword">string</span>, c *tls.Conn)</span> <span class="hljs-title">RoundTripper</span></span>
   ProxyConnectHeader Header
   GetProxyConnectHeader <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, proxyURL *url.URL, target <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(Header, error)</span></span>
   MaxResponseHeaderBytes <span class="hljs-keyword">int64</span>

   WriteBufferSize <span class="hljs-keyword">int</span>

   <span class="hljs-comment">// ReadBufferSize specifies the size of the read buffer used</span>
   <span class="hljs-comment">// when reading from the transport.</span>
   <span class="hljs-comment">// If zero, a default (currently 4KB) is used.</span>
   ReadBufferSize <span class="hljs-keyword">int</span>

   <span class="hljs-comment">// nextProtoOnce guards initialization of TLSNextProto and</span>
   <span class="hljs-comment">// h2transport (via onceSetNextProtoDefaults)</span>
   nextProtoOnce      sync.Once
   h2transport        h2Transport <span class="hljs-comment">// non-nil if http2 wired up</span>
   tlsNextProtoWasNil <span class="hljs-keyword">bool</span>        <span class="hljs-comment">// whether TLSNextProto was nil when the Once fired</span>

   <span class="hljs-comment">// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero</span>
   <span class="hljs-comment">// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.</span>
   <span class="hljs-comment">// By default, use of any those fields conservatively disables HTTP/2.</span>
   <span class="hljs-comment">// To use a custom dialer or TLS config and still attempt HTTP/2</span>
   <span class="hljs-comment">// upgrades, set this to true.</span>
   ForceAttemptHTTP2 <span class="hljs-keyword">bool</span>
&#125;</code></pre>
<h3 id="发起tcp连接的步骤"><a href="#发起tcp连接的步骤" class="headerlink" title="发起tcp连接的步骤"></a>发起tcp连接的步骤</h3><ul>
<li>构造http请求参数</li>
<li>获取tcp连接</li>
<li>通过tcp连接发送数据</li>
<li>通过tcp连接接受数据</li>
</ul>
<h4 id="t-Transport-roundTrip-req-Request-Response-error"><a href="#t-Transport-roundTrip-req-Request-Response-error" class="headerlink" title="(t Transport) roundTrip(req *Request)(Response, error)"></a>(t <em>Transport) roundTrip(req *Request)(</em>Response, error)</h4><pre><code class="hljs golang"><span class="hljs-comment">// roundTrip implements a RoundTripper over HTTP.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Transport)</span> <span class="hljs-title">roundTrip</span><span class="hljs-params">(req *Request)</span> <span class="hljs-params">(*Response, error)</span></span> &#123;
    <span class="hljs-comment">// ...</span>

   <span class="hljs-keyword">for</span> &#123;
     <span class="hljs-comment">// ... </span>
      pconn, err := t.getConn(treq, cm) <span class="hljs-comment">// 获取tcp连接，会从空闲池优先获取</span>
      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
         t.setReqCanceler(cancelKey, <span class="hljs-literal">nil</span>)
         req.closeBody()
         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
      &#125;

      <span class="hljs-keyword">var</span> resp *Response
      <span class="hljs-keyword">if</span> pconn.alt != <span class="hljs-literal">nil</span> &#123;
         <span class="hljs-comment">// HTTP/2 path.</span>
         t.setReqCanceler(cancelKey, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// not cancelable with CancelRequest</span>
         resp, err = pconn.alt.RoundTrip(req)  <span class="hljs-comment">// tcp的连接</span>
      &#125; <span class="hljs-keyword">else</span> &#123;
         resp, err = pconn.roundTrip(treq) <span class="hljs-comment">// tcp的连接</span>
      &#125;
      <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;
         resp.Request = origReq
         <span class="hljs-keyword">return</span> resp, <span class="hljs-literal">nil</span>
      &#125;

        <span class="hljs-comment">// ... </span>
   &#125;
&#125;</code></pre>

<h4 id="构造连接-t-Transport-dialConn-ctx-context-Context-cm-connectMethod-pconn-persistConn-err-error"><a href="#构造连接-t-Transport-dialConn-ctx-context-Context-cm-connectMethod-pconn-persistConn-err-error" class="headerlink" title="构造连接 (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error)"></a>构造连接 (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error)</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Transport)</span> <span class="hljs-title">dialConn</span><span class="hljs-params">(ctx context.Context, cm connectMethod)</span> <span class="hljs-params">(pconn *persistConn, err error)</span></span> &#123;
   pconn = &amp;persistConn&#123;
      t:             t,
      cacheKey:      cm.key(),
      reqch:         <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> requestAndChan, <span class="hljs-number">1</span>), <span class="hljs-comment">// 读channel</span>
      writech:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> writeRequest, <span class="hljs-number">1</span>), <span class="hljs-comment">// 写channel</span>
      closech:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),
      writeErrCh:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">1</span>),
      writeLoopDone: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),
   &#125;
   <span class="hljs-comment">// ...</span>
   conn, err := t.dial(ctx, <span class="hljs-string">"tcp"</span>, cm.addr())
    <span class="hljs-comment">// ...</span>
   pconn.conn = conn

    <span class="hljs-comment">// ...</span>

   <span class="hljs-keyword">go</span> pconn.readLoop() <span class="hljs-comment">// 将tcp连接中读取的数据放入读channel</span>
   <span class="hljs-keyword">go</span> pconn.writeLoop()<span class="hljs-comment">// 将需要写入的tcp连接的数据放入写channel</span>
   <span class="hljs-keyword">return</span> pconn, <span class="hljs-literal">nil</span>
&#125;</code></pre>
<h4 id="三个loop-goroutine"><a href="#三个loop-goroutine" class="headerlink" title="三个loop goroutine"></a>三个loop goroutine</h4><ul>
<li>pconn.readLoop() ：将tcp服务端的响应放入read channel中：生产读channel</li>
<li>pconn.writeLoop()： 将需要写入的tcp连接的数据放入写channel：消费写channel</li>
<li>主goroutine：处理程序的请求和响应动作，处理另外两个goroutine的channel的数据（消费读channel数据， 生产写channel数据）<br>通过channel，实现三个goroutine的通信， 解耦单个连接通道的阻塞，避免每个请求都要阻塞等待服务端响应，使读写互不干扰</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Go/">Go</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Go/">Go</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2023/04/26/drpc%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E6%94%B9%E9%80%A0/">
                        <span class="hidden-mobile">drpc的代码生成工具的简单改造</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("05/22/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站勉强安全运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  </script>
</div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->


  

  

  
    <!-- Tencent Analytics -->
    <script defer>
      var _mtac = {};
      (function () {
        var mta = document.createElement("script");
        mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500720703");
        
        mta.setAttribute("cid", "500720705");
        
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
      })();
    </script>
  

  

  

  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "go net/http的小总结&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
